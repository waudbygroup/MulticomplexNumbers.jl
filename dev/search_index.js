var documenterSearchIndex = {"docs":
[{"location":"applications/nmr/#nmr-applications","page":"NMR Spectroscopy","title":"NMR Spectroscopy","text":"This tutorial demonstrates how to use multicomplex numbers for multi-dimensional NMR spectroscopy data processing.\n\n","category":"section"},{"location":"applications/nmr/#Background:-Why-Multicomplex-Numbers-for-NMR?","page":"NMR Spectroscopy","title":"Background: Why Multicomplex Numbers for NMR?","text":"In NMR spectroscopy:\n\nEach time-domain dimension uses quadrature detection, recording both real and imaginary components\nA 2D NMR experiment produces data that is complex in both the direct and indirect dimensions\nTraditional approaches store this as complex arrays with special conventions for higher dimensions\n\nMulticomplex numbers provide a natural, unified representation:\n\nOrder 2 (bicomplex) for 2D NMR: z = a + b*i₁ + c*i₂ + d*i₁i₂\nOrder 3 (tricomplex) for 3D NMR: 8 components representing all combinations\nOrder 4 for 4D NMR, etc.\n\nWhere:\n\ni₁ represents the imaginary component of the direct (acquisition) dimension\ni₂ represents the imaginary component of the first indirect dimension\ni₃ represents the imaginary component of the second indirect dimension\nAnd so on...\n\n","category":"section"},{"location":"applications/nmr/#Tutorial:-Processing-2D-NMR-Data","page":"NMR Spectroscopy","title":"Tutorial: Processing 2D NMR Data","text":"","category":"section"},{"location":"applications/nmr/#Step-1:-Setup","page":"NMR Spectroscopy","title":"Step 1: Setup","text":"using MulticomplexNumbers\nusing FFTW  # Loads the FFT extension","category":"section"},{"location":"applications/nmr/#Step-2:-Creating-Synthetic-NMR-Data","page":"NMR Spectroscopy","title":"Step 2: Creating Synthetic NMR Data","text":"Let's create a synthetic 2D NMR signal to demonstrate the workflow:\n\n\"\"\"\nCreate a synthetic 2D NMR time-domain signal.\n\n# Arguments\n- `n1::Int`: Number of points in direct dimension\n- `n2::Int`: Number of points in indirect dimension\n- `freq1::Float64`: Frequency in direct dimension (Hz)\n- `freq2::Float64`: Frequency in indirect dimension (Hz)\n- `decay1::Float64`: Decay rate in direct dimension (1/s)\n- `decay2::Float64`: Decay rate in indirect dimension (1/s)\n\"\"\"\nfunction create_2d_fid(n1, n2, freq1, freq2, decay1=5.0, decay2=3.0)\n    # Allocate bicomplex array\n    fid = Array{Multicomplex{Float64, 2, 4}}(undef, n1, n2)\n\n    # Generate time-domain signal\n    for j in 1:n2\n        t2 = (j-1) / n2  # Indirect dimension time\n\n        # Indirect dimension signal\n        s2_r = cos(2π * freq2 * t2) * exp(-t2 * decay2)\n        s2_i = sin(2π * freq2 * t2) * exp(-t2 * decay2)\n\n        for i in 1:n1\n            t1 = (i-1) / n1  # Direct dimension time\n\n            # Direct dimension signal\n            s1_r = cos(2π * freq1 * t1) * exp(-t1 * decay1)\n            s1_i = sin(2π * freq1 * t1) * exp(-t1 * decay1)\n\n            # Combine as bicomplex: (s1_r + s1_i*im1) * (s2_r + s2_i*im2)\n            fid[i, j] = Multicomplex(\n                s1_r * s2_r,     # Real-real component\n                s1_i * s2_r,     # im1 coefficient\n                s1_r * s2_i,     # im2 coefficient\n                s1_i * s2_i      # im1*im2 coefficient\n            )\n        end\n    end\n\n    return fid\nend\n\n# Create test data: 128 × 64 points, peaks at 10 Hz (F1) and 15 Hz (F2)\nfid = create_2d_fid(128, 64, 10.0, 15.0)","category":"section"},{"location":"applications/nmr/#Step-3:-Fourier-Transform","page":"NMR Spectroscopy","title":"Step 3: Fourier Transform","text":"Key principle: Associate each imaginary unit with its corresponding array dimension.\n\n# Transform direct dimension (im1 along dimension 1)\nfft!(fid, 1, dims=1)\n\n# Transform indirect dimension (im2 along dimension 2)\nfft!(fid, 2, dims=2)\n\n# Now fid contains the 2D frequency-domain spectrum\n\nThis pattern is clean and intuitive: im1 ↔ dimension 1, im2 ↔ dimension 2.","category":"section"},{"location":"applications/nmr/#Step-4:-Phase-Correction","page":"NMR Spectroscopy","title":"Step 4: Phase Correction","text":"Phase errors are common in NMR. Correct them by multiplying by phase factors:\n\n# Zero-order phase correction: multiply by exp(imN * θ)\nfid .*= exp(im1 * π/6)   # 30° correction for direct dimension\nfid .*= exp(im2 * π/4)   # 45° correction for indirect dimension\n\nFor first-order (linear) phase correction, apply varying phases across the dimension:\n\n# First-order correction: 0° to 180° across direct dimension\nn = size(fid, 1)\nfor i in 1:n\n    θ = π * (i - 1) / n\n    fid[i, :] .*= exp(im1 * θ)\nend","category":"section"},{"location":"applications/nmr/#Step-5:-Extracting-Complex-Sub-Components","page":"NMR Spectroscopy","title":"Step 5: Extracting Complex Sub-Components","text":"After processing, you often need to extract specific complex projections for visualization or further analysis.","category":"section"},{"location":"applications/nmr/#Extracting-Real/Im1-Component","page":"NMR Spectroscopy","title":"Extracting Real/Im1 Component","text":"This gives you the spectrum as if only im1 were the complex unit (traditional F1 view):\n\n# Method 1: Using real() to get order-1 multicomplex\nspectrum_im1 = real.(fid)  # Returns array of Multicomplex{Float64, 1, 2}\n\n# Convert to standard Complex for plotting\ncomplex_f1 = [Complex(realest(z), imag(z)) for z in spectrum_im1]\n\n# Method 2: Using ascomplex (creates a view)\n# Note: ascomplex expects contiguous memory, so we may need to reshape\nspectrum_1d = vec(spectrum_im1)\ncomplex_view = ascomplex(spectrum_1d, 1)","category":"section"},{"location":"applications/nmr/#Extracting-Real/Im2-Component","page":"NMR Spectroscopy","title":"Extracting Real/Im2 Component","text":"This gives you the spectrum with im2 as the complex unit:\n\n\"\"\"Extract the real + im2*i component from bicomplex data.\"\"\"\nfunction extract_real_im2(data::Array{<:Multicomplex{T,2,4}}) where T\n    n1, n2 = size(data)\n    result = Array{Complex{T}}(undef, n1, n2)\n\n    for j in 1:n2, i in 1:n1\n        z = data[i, j]\n        # Component 1 is real, component 3 is im2 coefficient\n        result[i, j] = Complex(component(z, 1), component(z, 3))\n    end\n\n    return result\nend\n\ncomplex_f2 = extract_real_im2(fid)","category":"section"},{"location":"applications/nmr/#Extracting-Magnitude-Spectrum","page":"NMR Spectroscopy","title":"Extracting Magnitude Spectrum","text":"For publication, you typically want the magnitude (absolute value):\n\n# Most real component magnitude\nmagnitude = abs.(realest.(fid))\n\n# Or full multicomplex magnitude\nmagnitude_full = abs.(fid)\n\n","category":"section"},{"location":"applications/nmr/#Complete-2D-NMR-Processing-Example","page":"NMR Spectroscopy","title":"Complete 2D NMR Processing Example","text":"Here's a complete workflow:\n\nusing MulticomplexNumbers\nusing FFTW\n\n# 1. Create or load data\nfid = create_2d_fid(256, 128, 12.5, 8.3)\n\n# 2. Apply apodization (window function) if desired\nfunction apply_exponential_window!(data, lb1, lb2)\n    n1, n2 = size(data)\n\n    for j in 1:n2, i in 1:n1\n        t1 = (i-1) / n1\n        t2 = (j-1) / n2\n        window = exp(-π * lb1 * t1) * exp(-π * lb2 * t2)\n        data[i, j] *= window\n    end\n\n    return data\nend\n\napply_exponential_window!(fid, 2.0, 1.0)  # 2 Hz in F1, 1 Hz in F2\n\n# 3. Zero-fill (optional, for higher digital resolution)\nfunction zero_fill(data, new_n1, new_n2)\n    n1, n2 = size(data)\n    T = eltype(data)\n    result = zeros(T, new_n1, new_n2)\n    result[1:n1, 1:n2] .= data\n    return result\nend\n\nfid = zero_fill(fid, 512, 256)\n\n# 4. FFT\nfft!(fid, 1, dims=1)  # Direct dimension\nfft!(fid, 2, dims=2)  # Indirect dimension\n\n# 5. Phase correction\nfid .*= exp(im1 * π/8)   # 22.5° for direct dimension\nfid .*= exp(im2 * π/6)   # 30° for indirect dimension\n\n# 6. Extract magnitude for plotting\nmagnitude = abs.(realest.(fid))\n\n# 7. Find peak maximum\nmax_val, max_idx = findmax(magnitude)\nprintln(\"Peak at index $(max_idx.I) with intensity $(max_val)\")\n\n# 8. Extract complex projections if needed\nf1_projection = extract_real_im2(fid)    # F1 dimension\nf2_projection = [Complex(realest(z), imag(z)) for z in real.(fid)]  # F2 dimension\n\n","category":"section"},{"location":"applications/nmr/#3D-NMR-Processing","page":"NMR Spectroscopy","title":"3D NMR Processing","text":"For 3D experiments, use tricomplex numbers (order 3):\n\nusing MulticomplexNumbers\nusing FFTW\n\n# Create 3D data\nfid_3d = Array{Multicomplex{Float64, 3, 8}}(undef, 128, 64, 32)\n\n# ... fill with experimental data ...\n\n# Transform each dimension with its associated unit\nfft!(fid_3d, 1, dims=1)  # Direct dimension (im1)\nfft!(fid_3d, 2, dims=2)  # First indirect (im2)\nfft!(fid_3d, 3, dims=3)  # Second indirect (im3)\n\n# Phase correction for each dimension\nfid_3d .*= exp(im1 * 0.1)   # Direct\nfid_3d .*= exp(im2 * 0.2)   # First indirect\nfid_3d .*= exp(im3 * 0.15)  # Second indirect\n\n# Extract magnitude\nmagnitude_3d = abs.(realest.(fid_3d))\n\n","category":"section"},{"location":"applications/nmr/#Advanced:-Selective-Dimension-Processing","page":"NMR Spectroscopy","title":"Advanced: Selective Dimension Processing","text":"Sometimes you want to process only specific dimensions:\n\nusing MulticomplexNumbers\nusing FFTW\n\n# 2D array of bicomplex numbers\ndata = create_2d_fid(128, 128, 10.0, 15.0)\n\n# Process only the direct dimension\nfft!(data, 1, dims=1)\n# Now: frequency in F1, time in F2\n\n# Apply phase correction only to the transformed dimension\ndata .*= exp(im1 * π/4)\n\n# Later, transform F2\nfft!(data, 2, dims=2)\ndata .*= exp(im2 * π/6)\n\n","category":"section"},{"location":"applications/nmr/#Tips-for-Real-NMR-Data","page":"NMR Spectroscopy","title":"Tips for Real NMR Data","text":"Data Loading: Convert your NMR data to bicomplex/tricomplex format:\nfunction nmr_to_bicomplex(real_part, imag_part_1, imag_part_2, cross_part)\n    n1, n2 = size(real_part)\n    result = Array{Multicomplex{Float64, 2, 4}}(undef, n1, n2)\n\n    for j in 1:n2, i in 1:n1\n        result[i, j] = Multicomplex(\n            real_part[i, j],\n            imag_part_1[i, j],\n            imag_part_2[i, j],\n            cross_part[i, j]\n        )\n    end\n\n    return result\nend\nStates-TPPI, Echo-AntiEcho: Different acquisition modes will affect how you construct the multicomplex array. Consult your spectrometer's documentation.\nLinear Prediction: Can be applied before FFT to extend the FID:\n# Apply LP separately to each complex component\n# This would require extracting components, applying LP, and reconstructing\nBaseline Correction: Usually applied to the magnitude spectrum after all processing.\nIntegration with NMRTools.jl: For production NMR processing, see NMRTools.jl, which builds on this package with additional NMR-specific functionality.\n\n","category":"section"},{"location":"applications/nmr/#Performance-Considerations","page":"NMR Spectroscopy","title":"Performance Considerations","text":"In-place Operations: fft! modifies the array in-place. Copy if you need the original:\nfid_copy = copy(fid)\nfft!(fid_copy, 1, dims=1)\nMemory Layout: Multicomplex arrays are cache-friendly - all components are stored contiguously.\nType Stability: Keep types consistent (don't mix Float32/Float64) for best performance.\nPreallocate: Reuse arrays when processing multiple spectra:\nworkspace = similar(fid)\nfor spectrum in spectra\n    workspace .= spectrum\n    fft!(workspace, 1, dims=1)\n    fft!(workspace, 2, dims=2)\n    # ... process workspace ...\nend\n\n","category":"section"},{"location":"applications/nmr/#See-Also","page":"NMR Spectroscopy","title":"See Also","text":"FFT Operations: Detailed FFT documentation\nAccessing Components: Extract parts and components\nExamples: Quick code snippets\nAPI Reference: Complete function documentation\nNMRTools.jl: Production NMR processing toolkit","category":"section"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This guide will help you get up and running with MulticomplexNumbers.jl quickly.","category":"section"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"MulticomplexNumbers.jl is a registered Julia package. Install it using Julia's package manager:\n\nusing Pkg\nPkg.add(\"MulticomplexNumbers\")\n\nOr in the package REPL (press ]):\n\npkg> add MulticomplexNumbers","category":"section"},{"location":"getting-started/#Optional:-FFT-Support","page":"Getting Started","title":"Optional: FFT Support","text":"For Fourier transform capabilities, also install FFTW:\n\nPkg.add(\"FFTW\")","category":"section"},{"location":"getting-started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"using MulticomplexNumbers","category":"section"},{"location":"getting-started/#Creating-Multicomplex-Numbers","page":"Getting Started","title":"Creating Multicomplex Numbers","text":"The package provides imaginary units im1 through im6 for constructing multicomplex numbers:\n\n# Order 1: Complex numbers (2 components)\nz1 = 1.0 + 2.0*im1\n\n# Order 2: Bicomplex numbers (4 components)\nz2 = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\n\n# Order 3: Tricomplex numbers (8 components)\nz3 = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im3\n\nYou can also use direct constructors:\n\n# From real components\nMulticomplex(1.0, 2.0)           # = 1 + 2*im1\nMulticomplex(1.0, 2.0, 3.0, 4.0) # = 1 + 2*im1 + 3*im2 + 4*im1*im2\n\n# From Complex numbers\nMulticomplex(1.0 + 2.0im)        # = 1 + 2*im1","category":"section"},{"location":"getting-started/#Key-Properties","page":"Getting Started","title":"Key Properties","text":"Each imaginary unit squares to -1:\n\nim1 * im1\nim2 * im2\n\nUnlike quaternions, multicomplex units commute:\n\nim1 * im2 == im2 * im1\n\nHowever, the product of different units is hyperbolic (squares to +1):\n\n(im1 * im2)^2","category":"section"},{"location":"getting-started/#Arithmetic-Operations","page":"Getting Started","title":"Arithmetic Operations","text":"All standard operations are supported:\n\na = 1.0 + 2.0*im1 + 3.0*im2\nb = 2.0 + 1.0*im1 - 1.0*im2\n\n# Addition and subtraction\na + b\na - b\n\n# Multiplication and division\na * b\na / b\n\n# Powers and transcendental functions\na^2\nexp(a)\nlog(a)\nsqrt(a)","category":"section"},{"location":"getting-started/#Extracting-Components","page":"Getting Started","title":"Extracting Components","text":"z = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\n\n# Real and imaginary parts (returns multicomplex of order N-1)\nreal(z)\nimag(z)\n\n# Get all components as a vector\nflat(z)\n\n# Get the \"most real\" component (first component)\nrealest(z)\n\n# Get a specific component by index\ncomponent(z, 2)  # The im1 coefficient","category":"section"},{"location":"getting-started/#Quick-Example:-Numerical-Differentiation","page":"Getting Started","title":"Quick Example: Numerical Differentiation","text":"The most powerful application of multicomplex numbers is computing derivatives with machine precision:\n\n# Compute the derivative of f(x) = sin(x) at x = π/4\nf(x) = sin(x)\n\n# Use an extremely small step size (impossible with finite differences!)\nh = 1e-100\nx = π/4 + h*im1\n\n# Evaluate the function\nresult = f(x)\n\n# Extract the derivative from the imaginary part\nderivative = imag(result) / h\n\n# Compare to exact value: cos(π/4) = √2/2 ≈ 0.7071...\ncos(π/4)\n\nThe result matches the exact derivative to machine precision!","category":"section"},{"location":"getting-started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Background: Learn the mathematics behind multicomplex numbers\nUser Guide: Detailed exploration of all features:\nCreating Numbers\nArithmetic Operations\nAccessing Components\nFFT Operations\nApplications: Practical examples:\nNMR Spectroscopy\nNumerical Differentiation\nAPI Reference: Complete function documentation","category":"section"},{"location":"applications/differentiation/#differentiation-applications","page":"Numerical Differentiation","title":"Numerical Differentiation","text":"This tutorial demonstrates how to use the multicomplex step method for high-precision numerical differentiation.\n\n","category":"section"},{"location":"applications/differentiation/#The-Multicomplex-Step-Method","page":"Numerical Differentiation","title":"The Multicomplex Step Method","text":"The multicomplex step method extends the complex step derivative to compute higher-order derivatives with machine precision accuracy, avoiding the subtractive cancellation errors that plague finite difference methods.\n\n","category":"section"},{"location":"applications/differentiation/#Background:-The-Problem-with-Finite-Differences","page":"Numerical Differentiation","title":"Background: The Problem with Finite Differences","text":"Traditional numerical differentiation uses finite differences:\n\nf(x) approx fracf(x+h) - f(x)h\n\nThis suffers from a fundamental trade-off:\n\nLarge h: Truncation error dominates (formula is only approximate)\nSmall h: Roundoff error dominates (subtractive cancellation in f(x+h) - f(x))\n\nThe optimal h is typically around √ε ≈ 10⁻⁸ for Float64, limiting accuracy to about 8 digits.\n\n","category":"section"},{"location":"applications/differentiation/#The-Complex-Step-Method","page":"Numerical Differentiation","title":"The Complex Step Method","text":"For an analytic function f, we have the Taylor expansion:\n\nf(x + ih) = f(x) + ih cdot f(x) - frach^22f(x) - fracih^36f(x) + \n\nTaking the imaginary part:\n\ntextImf(x + ih) = h cdot f(x) + O(h^3)\n\nThus:\n\nf(x) approx fractextImf(x + ih)h\n\nSince we're not computing a difference, there's no subtractive cancellation! We can use arbitrarily small h, giving nearly machine-precision derivatives.\n\n","category":"section"},{"location":"applications/differentiation/#First-Derivatives-with-im1","page":"Numerical Differentiation","title":"First Derivatives with im1","text":"using MulticomplexNumbers\n\n# Define a test function\nf(x) = sin(x) * exp(-x^2)\n\n# Compute derivative at x = 0.5\nx = 0.5\nh = 1e-100  # Extremely small step - impossible with finite differences!\n\n# Evaluate f at x + h*im1\nresult = f(x + h*im1)\n\n# Extract derivative from imaginary part\nf_prime = imag(result) / h\n\n# Compute exact derivative: f'(x) = cos(x)*exp(-x²) - 2x*sin(x)*exp(-x²)\nexact = cos(x)*exp(-x^2) - 2x*sin(x)*exp(-x^2)\n\n# Error\nabs(f_prime - exact)\n\nThe error is at the level of machine epsilon!\n\n","category":"section"},{"location":"applications/differentiation/#Second-Derivatives-with-im1-and-im2","page":"Numerical Differentiation","title":"Second Derivatives with im1 and im2","text":"For second derivatives, we use bicomplex numbers (im1 and im2):\n\nf(x) approx fractextcomponent_i_1 i_2f(x + h cdot i_1 + h cdot i_2)h^2\n\nusing MulticomplexNumbers\n\n# Compute second derivative of f(x) = x^4 at x = 2\n# Exact answer: f''(x) = 12x² = 48\n\nx = 2.0\nh = 1e-50\n\n# Evaluate at x + h*im1 + h*im2\nresult = (x + h*im1 + h*im2)^4\n\n# The i₁i₂ component is at index 4: [1, i₁, i₂, i₁i₂]\nsecond_derivative = component(result, 4) / h^2\n\n# Exact value\nexact = 12 * x^2\n\nabs(second_derivative - exact)\n\n","category":"section"},{"location":"applications/differentiation/#Third-Derivatives-with-im1,-im2,-and-im3","page":"Numerical Differentiation","title":"Third Derivatives with im1, im2, and im3","text":"using MulticomplexNumbers\n\n# Compute third derivative of f(x) = x^5 at x = 1\n# Exact answer: f'''(x) = 60x² = 60\n\nx = 1.0\nh = 1e-30\n\n# Evaluate at x + h*im1 + h*im2 + h*im3\nresult = (x + h*im1 + h*im2 + h*im3)^5\n\n# The i₁i₂i₃ component is at index 8\nthird_derivative = component(result, 8) / h^3\n\nexact = 60.0\nabs(third_derivative - exact)\n\n","category":"section"},{"location":"applications/differentiation/#Practical-Derivative-Helper-Function","page":"Numerical Differentiation","title":"Practical Derivative Helper Function","text":"Here's a convenient wrapper function:\n\nusing MulticomplexNumbers\n\n\"\"\"\n    derivative(f, x, n=1; h=1e-50)\n\nCompute the n-th derivative of f at x using multicomplex step method.\n\n# Arguments\n- `f`: Function to differentiate\n- `x`: Point at which to evaluate the derivative\n- `n`: Order of derivative (1-4 supported)\n- `h`: Step size (default: 1e-50)\n\n# Returns\nThe n-th derivative of f at x\n\n# Examples\n\njulia f(x) = sin(x) derivative(f, 1.0, 1)  # First derivative at x=1 derivative(f, 1.0, 2)  # Second derivative at x=1\n\n\"\"\"\nfunction derivative(f, x::Real, n::Int=1; h::Real=1e-50)\n    if n < 1\n        return f(x)\n    elseif n == 1\n        result = f(x + h*im1)\n        return imag(result) / h\n    elseif n == 2\n        result = f(x + h*im1 + h*im2)\n        return component(result, 4) / h^2\n    elseif n == 3\n        result = f(x + h*im1 + h*im2 + h*im3)\n        return component(result, 8) / h^3\n    elseif n == 4\n        result = f(x + h*im1 + h*im2 + h*im3 + h*im4)\n        return component(result, 16) / h^4\n    else\n        error(\"Derivatives of order > 4 not implemented in this example\")\n    end\nend\n\n# Test it\nf(x) = sin(x)\nx = 1.0\n\nderivative(f, x, 1)  # f'(1) = cos(1) ≈ 0.5403\nderivative(f, x, 2)  # f''(1) = -sin(1) ≈ -0.8415\nderivative(f, x, 3)  # f'''(1) = -cos(1) ≈ -0.5403\nderivative(f, x, 4)  # f''''(1) = sin(1) ≈ 0.8415\n\n","category":"section"},{"location":"applications/differentiation/#Applications","page":"Numerical Differentiation","title":"Applications","text":"","category":"section"},{"location":"applications/differentiation/#Numerical-Optimization","page":"Numerical Differentiation","title":"Numerical Optimization","text":"Compute exact gradients and Hessians:\n\nusing MulticomplexNumbers\n\n# Rosenbrock function\nrosenbrock(x, y) = (1 - x)^2 + 100 * (y - x^2)^2\n\n# Gradient at (0.5, 0.5)\nx, y = 0.5, 0.5\nh = 1e-50\n\n# Partial derivatives\n∂f_∂x = imag(rosenbrock(x + h*im1, y)) / h\n∂f_∂y = imag(rosenbrock(x, y + h*im1)) / h\n\nprintln(\"Gradient: ($(∂f_∂x), $(∂f_∂y))\")\n\n# Second partial: ∂²f/∂x²\n∂²f_∂x² = component(rosenbrock(x + h*im1 + h*im2, y), 4) / h^2","category":"section"},{"location":"applications/differentiation/#Sensitivity-Analysis","page":"Numerical Differentiation","title":"Sensitivity Analysis","text":"Compute how outputs change with respect to parameters:\n\nusing MulticomplexNumbers\n\n# Model: exponential decay\nfunction decay_model(t, A, k)\n    return A * exp(-k * t)\nend\n\n# Sensitivity of output to amplitude A at t=2.0\nt = 2.0\nA = 1.0\nk = 0.5\nh = 1e-50\n\nsensitivity_A = imag(decay_model(t, A + h*im1, k)) / h\nsensitivity_k = imag(decay_model(t, A, k + h*im1)) / h\n\nprintln(\"Sensitivity to A: $(sensitivity_A)\")\nprintln(\"Sensitivity to k: $(sensitivity_k)\")","category":"section"},{"location":"applications/differentiation/#Root-Finding-(Newton's-Method)","page":"Numerical Differentiation","title":"Root Finding (Newton's Method)","text":"Newton's method with exact derivatives:\n\nusing MulticomplexNumbers\n\n\"\"\"Newton's method using multicomplex derivatives.\"\"\"\nfunction newton(f, x0; tol=1e-10, maxiter=100)\n    x = x0\n    h = 1e-100\n\n    for i in 1:maxiter\n        fx = f(x)\n        fpx = imag(f(x + h*im1)) / h\n\n        if abs(fx) < tol\n            return x\n        end\n\n        x = x - fx / fpx\n    end\n\n    error(\"Newton's method did not converge\")\nend\n\n# Find root of f(x) = x^3 - 2x - 5\nf(x) = x^3 - 2x - 5\nroot = newton(f, 2.0)\nprintln(\"Root: $(root)\")\nprintln(\"Verification f(root) = $(f(root))\")\n\n","category":"section"},{"location":"applications/differentiation/#Practical-Tips","page":"Numerical Differentiation","title":"Practical Tips","text":"Step size: Use h ≈ 10⁻⁵⁰/n for the n-th derivative. Smaller is generally better (but not required for convergence).\nComponent indices: For an n-th derivative, extract component 2^n from an order-n multicomplex number:\n1st derivative: component 2 (index 2) from order 1\n2nd derivative: component 4 (index 4) from order 2\n3rd derivative: component 8 (index 8) from order 3\n4th derivative: component 16 (index 16) from order 4\nComputational cost: Storage and computation scale as 2^n for the n-th derivative. For orders above ~10, this becomes expensive.\nFunction requirements: Your function must:\nAccept multicomplex arguments\nUse operations that work on them (+, -, *, /, ^, exp, log, sqrt, etc.)\nAvoid type-specific operations or branching based on exact values\nComparison with AD:\nMulticomplex is simpler to implement (just change the input type)\nAD (via ForwardDiff.jl) is more efficient for gradients of functions ℝⁿ → ℝ\nMulticomplex excels for high-order derivatives of scalar functions\n\n","category":"section"},{"location":"applications/differentiation/#Limitations","page":"Numerical Differentiation","title":"Limitations","text":"Analytic functions only: The function must be complex-analytic (or at least extend to multicomplex arguments)\nNo branching: Avoid conditionals that depend on exact values:\n# Bad: branching on exact value\nf(x) = x > 0 ? sqrt(x) : 0\n\n# Good: smooth approximation\nf(x) = x > 0 ? sqrt(x) : sqrt(x^2 + 1e-10) - 1e-5\nComputational cost: Each order doubles the component count and computational cost\nVery high orders: Beyond order ~6, consider other methods (symbolic differentiation, AD with nested dual numbers, etc.)\n\n","category":"section"},{"location":"applications/differentiation/#References","page":"Numerical Differentiation","title":"References","text":"Complex Step Approximation: Nick Higham's blog\nOriginal Method: Lantoine, G., Russell, R. P., Dargent, T. (2012). \"Using Multicomplex Variables for Automatic Computation of High-order Derivatives.\" ACM TOMS 38(3):16.\nNIST Report: Bell, I. H., Deiters, U. K. (2021). \"Precise Numerical Differentiation of Thermodynamic Functions with Multicomplex Variables.\" NIST J. Res. 126:033\n\n","category":"section"},{"location":"applications/differentiation/#See-Also","page":"Numerical Differentiation","title":"See Also","text":"Creating Numbers: How to create multicomplex numbers\nArithmetic Operations: Mathematical operations\nExamples: Quick code snippets\nAPI Reference: Complete function documentation","category":"section"},{"location":"guide/arithmetic/#arithmetic","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"This page covers all arithmetic operations supported by multicomplex numbers.\n\n","category":"section"},{"location":"guide/arithmetic/#Basic-Arithmetic","page":"Arithmetic Operations","title":"Basic Arithmetic","text":"using MulticomplexNumbers\n\na = 1.0 + 2.0*im1 + 3.0*im2\nb = 2.0 - 1.0*im1 + 0.5*im2\n\n# Addition and subtraction\na + b\na - b\n-a\n\n# Scalar operations\n3.0 * a\na / 2.0\na + 5.0\n\n","category":"section"},{"location":"guide/arithmetic/#Multiplication","page":"Arithmetic Operations","title":"Multiplication","text":"Multicomplex multiplication uses the matrix representation internally:\n\nusing MulticomplexNumbers\n\na = 1.0 + 2.0*im1\nb = 3.0 + 4.0*im1\n\na * b  # = (1*3 - 2*4) + (1*4 + 2*3)*im1 = -5 + 10*im1\n\n# Verify the algebra\nim1 * im1  # = -1\nim1 * im2  # = im1*im2 (distinct product)\nim2 * im1  # Commutative!\n\n","category":"section"},{"location":"guide/arithmetic/#Division","page":"Arithmetic Operations","title":"Division","text":"Division works except when dividing by zero divisors:\n\nusing MulticomplexNumbers\n\na = 1.0 + 2.0*im1\nb = 3.0 + 4.0*im1\n\na / b\ninv(b)  # = 1/b\n\nwarning: Zero Divisors\nFor N ≥ 2, some non-zero multicomplex numbers cannot be inverted:z = 1.0 + 1.0*im1*im2  # This has a zero divisor issue\n# (1 + im1*im2)(1 - im1*im2) = 1 - (im1*im2)² = 1 - 1 = 0\n\n","category":"section"},{"location":"guide/arithmetic/#Powers","page":"Arithmetic Operations","title":"Powers","text":"using MulticomplexNumbers\n\nz = 1.0 + 0.5*im1\n\nz^2\nz^3\nz^0.5  # Non-integer powers work too\nz^(-1)  # Same as inv(z)\n\n","category":"section"},{"location":"guide/arithmetic/#Transcendental-Functions","page":"Arithmetic Operations","title":"Transcendental Functions","text":"using MulticomplexNumbers\n\nz = 0.5 + 0.25*im1\n\nexp(z)\nlog(z)\nsqrt(z)\n\n# Verify: exp(log(z)) ≈ z\nexp(log(z))\n\n","category":"section"},{"location":"guide/arithmetic/#Conjugation","page":"Arithmetic Operations","title":"Conjugation","text":"Conjugation inverts the sign of the highest-order imaginary component:\n\nusing MulticomplexNumbers\n\nz = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\n\nconj(z)  # Inverts im2 component sign\n\n# For order 1, this matches complex conjugation\nw = 1.0 + 2.0*im1\nconj(w)\n\n","category":"section"},{"location":"guide/arithmetic/#Absolute-Values-and-Norms","page":"Arithmetic Operations","title":"Absolute Values and Norms","text":"using MulticomplexNumbers\nusing LinearAlgebra\n\nz = 3.0 + 4.0*im1\n\nabs2(z)  # Sum of squares of components\nabs(z)   # sqrt(abs2(z))\nnorm(z)  # Euclidean norm (same as abs for order 1)\n\n","category":"section"},{"location":"guide/arithmetic/#Testing-Properties","page":"Arithmetic Operations","title":"Testing Properties","text":"using MulticomplexNumbers\n\nz = 1.0 + 2.0*im1\nw = 5.0 + 0.0*im1\n\nisreal(z)   # false\nisreal(w)   # true (imaginary part is zero)\n\nisinteger(w)  # true\nisinteger(z)  # false\n\niszero(z)     # false\niszero(0.0 + 0.0*im1)  # true\n\nisone(1.0 + 0.0*im1)   # true\n\nisfinite(z)  # true\nisnan(z)     # false\nisinf(z)     # false\n\n","category":"section"},{"location":"guide/arithmetic/#See-Also","page":"Arithmetic Operations","title":"See Also","text":"Creating Numbers: How to create multicomplex numbers\nAccessing Components: Extract parts and components\nAPI Reference: Complete function documentation","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page provides complete documentation for all exported types and functions.\n\n","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Constants","page":"API Reference","title":"Constants","text":"","category":"section"},{"location":"api/#Imaginary-Units","page":"API Reference","title":"Imaginary Units","text":"The package exports imaginary units im1 through im6 for conveniently constructing multicomplex numbers.\n\nAdditional units im2, im3, im4, im5, and im6 follow the same pattern for higher orders.\n\n","category":"section"},{"location":"api/#Component-Access","page":"API Reference","title":"Component Access","text":"","category":"section"},{"location":"api/#Order","page":"API Reference","title":"Order","text":"","category":"section"},{"location":"api/#Flat-Components","page":"API Reference","title":"Flat Components","text":"","category":"section"},{"location":"api/#Individual-Components","page":"API Reference","title":"Individual Components","text":"","category":"section"},{"location":"api/#Real-Component","page":"API Reference","title":"Real Component","text":"","category":"section"},{"location":"api/#Representations","page":"API Reference","title":"Representations","text":"","category":"section"},{"location":"api/#Matrix-Representation","page":"API Reference","title":"Matrix Representation","text":"","category":"section"},{"location":"api/#Complex-View","page":"API Reference","title":"Complex View","text":"","category":"section"},{"location":"api/#Standard-Functions","page":"API Reference","title":"Standard Functions","text":"The following Base functions are extended for multicomplex numbers:","category":"section"},{"location":"api/#Real-and-Imaginary-Parts","page":"API Reference","title":"Real and Imaginary Parts","text":"real(m::Multicomplex): Returns the real part with respect to the highest imaginary unit (order N-1)\nimag(m::Multicomplex): Returns the imaginary part with respect to the highest imaginary unit (order N-1)","category":"section"},{"location":"api/#Arithmetic","page":"API Reference","title":"Arithmetic","text":"+, -: Addition and subtraction (element-wise on components)\n*: Multiplication (via matrix representation)\n/: Division (via matrix representation)\n^: Power (integer and real exponents)\ninv(m): Multiplicative inverse","category":"section"},{"location":"api/#Transcendental-Functions","page":"API Reference","title":"Transcendental Functions","text":"exp(m): Exponential\nlog(m): Natural logarithm\nsqrt(m): Square root","category":"section"},{"location":"api/#Trigonometric-Functions","page":"API Reference","title":"Trigonometric Functions","text":"sin(m): Sine\ncos(m): Cosine\ntan(m): Tangent\ncot(m): Cotangent\nsec(m): Secant\ncsc(m): Cosecant","category":"section"},{"location":"api/#Hyperbolic-Functions","page":"API Reference","title":"Hyperbolic Functions","text":"sinh(m): Hyperbolic sine\ncosh(m): Hyperbolic cosine\ntanh(m): Hyperbolic tangent\ncoth(m): Hyperbolic cotangent\nsech(m): Hyperbolic secant\ncsch(m): Hyperbolic cosecant","category":"section"},{"location":"api/#Inverse-Trigonometric-Functions","page":"API Reference","title":"Inverse Trigonometric Functions","text":"asin(m): Arcsine\nacos(m): Arccosine\natan(m): Arctangent\nacot(m): Arccotangent\nasec(m): Arcsecant\nacsc(m): Arccosecant","category":"section"},{"location":"api/#Inverse-Hyperbolic-Functions","page":"API Reference","title":"Inverse Hyperbolic Functions","text":"asinh(m): Inverse hyperbolic sine\nacosh(m): Inverse hyperbolic cosine\natanh(m): Inverse hyperbolic tangent\nacoth(m): Inverse hyperbolic cotangent\nasech(m): Inverse hyperbolic secant\nacsch(m): Inverse hyperbolic cosecant","category":"section"},{"location":"api/#Conjugation-and-Norms","page":"API Reference","title":"Conjugation and Norms","text":"conj(m): Multicomplex conjugation (negates highest imaginary part)\nabs(m): Absolute value (Euclidean norm)\nabs2(m): Squared absolute value","category":"section"},{"location":"api/#Comparisons-and-Properties","page":"API Reference","title":"Comparisons and Properties","text":"==, isequal: Equality comparison\nisreal(m): Check if all imaginary components are zero\nisinteger(m): Check if real and integer-valued\nisfinite(m): Check if all components are finite\nisnan(m): Check if any component is NaN\nisinf(m): Check if any component is infinite\niszero(m): Check if all components are zero\nisone(m): Check if equal to multiplicative identity","category":"section"},{"location":"api/#Type-Utilities","page":"API Reference","title":"Type Utilities","text":"zero(Multicomplex{T,N,C}): Additive identity\none(Multicomplex{T,N,C}): Multiplicative identity\nfloat(Multicomplex{T,N,C}): Convert to floating-point base type\n\n","category":"section"},{"location":"api/#Multicomplex-Specific-Operations","page":"API Reference","title":"Multicomplex-Specific Operations","text":"","category":"section"},{"location":"api/#Fold-Operator","page":"API Reference","title":"Fold Operator","text":"The fold operator multiplies a multicomplex number by its conjugate, reducing the order by one.","category":"section"},{"location":"api/#Abient-Numbers","page":"API Reference","title":"Abient Numbers","text":"A multicomplex number is \"abient\" if it becomes zero after sufficiently many foldings. This property arises because multicomplex numbers are not a composition algebra.\n\n","category":"section"},{"location":"api/#Random-Number-Generation","page":"API Reference","title":"Random Number Generation","text":"The package supports random number generation for multicomplex numbers:","category":"section"},{"location":"api/#Uniform-Distribution","page":"API Reference","title":"Uniform Distribution","text":"rand([rng], Multicomplex{T,N,C})\n\nGenerates a random multicomplex number with components drawn from the default distribution for type T.\n\nExample:\n\njulia> rand(Multicomplex{Float64,1,2})\n0.234 + 0.891*im1\n\njulia> rand(Multicomplex{Float64,2,4})\n(0.123 + 0.456*im1) + (0.789 + 0.234*im1)*im2","category":"section"},{"location":"api/#Normal-Distribution","page":"API Reference","title":"Normal Distribution","text":"randn([rng], Multicomplex{T,N,C}) where {T<:AbstractFloat}\n\nGenerates a random multicomplex number with components drawn from a standard normal distribution. Only available for floating-point types.\n\nExample:\n\njulia> randn(Multicomplex{Float64,1,2})\n-0.543 + 1.234*im1\n\njulia> randn(Multicomplex{Float64,2,4})\n(0.891 - 0.234*im1) + (-1.567 + 0.432*im1)*im2\n\n","category":"section"},{"location":"api/#FFT-Support-(FFTW-Extension)","page":"API Reference","title":"FFT Support (FFTW Extension)","text":"When FFTW.jl is loaded, the following function becomes available:","category":"section"},{"location":"api/#In-place-FFT","page":"API Reference","title":"In-place FFT","text":"fft!(A::AbstractArray{<:Multicomplex}, unit::Integer)\nfft!(A::AbstractArray{<:Multicomplex}, unit::Integer, dims)\n\nPerforms an in-place FFT on a multicomplex array, treating unit as the imaginary unit for the complex FFT.\n\nArguments:\n\nA: Array of multicomplex numbers\nunit: Which imaginary unit to use (1 for im1, 2 for im2, etc.)\ndims: Dimensions along which to compute the FFT (optional, defaults to all)\n\nSupported orders: N = 1, 2, 3, 4\n\nExample:\n\nusing MulticomplexNumbers\nusing FFTW\n\ndata = [Multicomplex(rand(4)...) for _ in 1:64]\nfft!(data, 1)  # FFT along im1\nfft!(data, 2)  # FFT along im2\n\n","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"Pages = [\"api.md\"]","category":"section"},{"location":"api/#MulticomplexNumbers.Multicomplex","page":"API Reference","title":"MulticomplexNumbers.Multicomplex","text":"Multicomplex{T,N,C}(value)\n\nDefines a multicomplex number ℂ_N, over base field T, having C=2^N components specified in static vector value.\n\nInput:     value::SVector{C, T})\n\n\n\n\n\n","category":"type"},{"location":"api/#MulticomplexNumbers.im1","page":"API Reference","title":"MulticomplexNumbers.im1","text":"im1, im2, im3, im4, im5, im6\n\nThe imaginary units, up to dimension 6.\n\n\n\n\n\n","category":"constant"},{"location":"api/#MulticomplexNumbers.order","page":"API Reference","title":"MulticomplexNumbers.order","text":"Order of the multicomplex number is the number of imaginary units\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.flat","page":"API Reference","title":"MulticomplexNumbers.flat","text":"Get components as a vector\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.component","page":"API Reference","title":"MulticomplexNumbers.component","text":"Utility function to extract a real-valued component from a multicomplex number\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.realest","page":"API Reference","title":"MulticomplexNumbers.realest","text":"Extract the 'most real' component\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.matrep","page":"API Reference","title":"MulticomplexNumbers.matrep","text":"matrix representation of a multicomplex number\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.ascomplex","page":"API Reference","title":"MulticomplexNumbers.ascomplex","text":"ascomplex(A::AbstractArray{M}, [unit])\n\nReturns a view of the multicomplex input array A as an array of complex numbers, mapping i(unit) -> im. If a unit is not supplied, defaults to the highest order.\n\nIf A has size (m, n, ...) with multicomplex numbers of dimension N, then the output will have size (2^(N-1), m, n, ...).\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.fold","page":"API Reference","title":"MulticomplexNumbers.fold","text":"fold(m::Multicomplex{T,N})\n\nFolding operation that multiplies a multicomplex number by its conjugate.\n\nWith w ∈ ℂₙ₊₁, fold(w) = w × conj(w) = conj(w) × w ∈ ℂₙ.\n\nThe fold operation reduces the order by 1:\n\nfold(ℂₙ) → ℂₙ₋₁\nfold(ℂ₁) → ℂ₀ (real numbers)\nfold(ℂ₀) → ℂ₀ (squaring)\n\nExamples\n\njulia> fold(1 + im1)\nMulticomplex(2.0)\n\njulia> fold(1 + im1*im2)  # (1 + i₁i₂)(1 - i₁i₂) = 0\nMulticomplex(0.0, 0.0)\n\nReferences\n\nSometimes the fold of a nonzero number turns out to be zero; for example, (1 + i₁i₂)(1 - i₁i₂) = 0. This illustrates that the norm is not always preserved under multiplication, thus the multicomplex numbers are not a composition algebra.\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.isabient","page":"API Reference","title":"MulticomplexNumbers.isabient","text":"isabient(m::Multicomplex; atol=0, rtol=atol>0 ? 0 : √eps)\n\nDetermine if a multicomplex number is abient.\n\nA multicomplex number is abient (from a Latin participle meaning \"going away\") if after sufficiently many foldings it becomes zero. After N foldings, an ℂₙ multicomplex number becomes a real number; if it turns out to be zero, the multicomplex number is abient.\n\nArguments\n\nm::Multicomplex: The multicomplex number to test\natol::Real=0: Absolute tolerance for zero comparison\nrtol::Real: Relative tolerance (defaults to √eps if atol=0)\n\nExamples\n\njulia> isabient(1 + im1)\nfalse\n\njulia> isabient(1 + im1*im2)  # (1 + i₁i₂) is abient\ntrue\n\nReferences\n\nNot to be confused with \"ambient\". This concept arises because multicomplex numbers are not a composition algebra - the norm is not always preserved under multiplication.\n\n\n\n\n\n","category":"function"},{"location":"guide/components/#components","page":"Accessing Components","title":"Accessing Components","text":"This page explains how to access and extract components from multicomplex numbers.\n\n","category":"section"},{"location":"guide/components/#Real-and-Imaginary-Parts","page":"Accessing Components","title":"Real and Imaginary Parts","text":"The real and imag functions return multicomplex numbers of order N-1:\n\nusing MulticomplexNumbers\n\nz = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\n\n# For order 2: real/imag return order 1\nreal(z)  # The \"real\" part with respect to im2\nimag(z)  # The \"imaginary\" part with respect to im2\n\n# Apply recursively\nreal(real(z))  # Gets the truly real component\n\n","category":"section"},{"location":"guide/components/#Direct-Component-Access","page":"Accessing Components","title":"Direct Component Access","text":"using MulticomplexNumbers\n\nz = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\n\n# Get all components as a vector\nflat(z)\n\n# Get a specific component (1-indexed)\ncomponent(z, 1)  # Coefficient of 1\ncomponent(z, 2)  # Coefficient of im1\ncomponent(z, 3)  # Coefficient of im2\ncomponent(z, 4)  # Coefficient of im1*im2\n\n# Get the first (most real) component\nrealest(z)\n\n","category":"section"},{"location":"guide/components/#Component-Ordering","page":"Accessing Components","title":"Component Ordering","text":"Components follow a binary pattern based on which imaginary units are present:\n\nOrder Index Basis Element\n1 1 1\n1 2 i₁\n2 1 1\n2 2 i₁\n2 3 i₂\n2 4 i₁i₂\n3 1 1\n3 2 i₁\n3 3 i₂\n3 4 i₁i₂\n3 5 i₃\n3 6 i₁i₃\n3 7 i₂i₃\n3 8 i₁i₂i₃\n\nThe pattern: index k has the units corresponding to bits set in k-1 (0-indexed).\n\n","category":"section"},{"location":"guide/components/#Order-and-Properties","page":"Accessing Components","title":"Order and Properties","text":"using MulticomplexNumbers\n\n# Get the order\norder(1.0 + im1)\norder(1.0 + im1 + im2)\n\n# Check properties\nisreal(5.0 + 0.0*im1)\nisreal(1.0 + 2.0*im1)\n\n","category":"section"},{"location":"guide/components/#Matrix-Representations","page":"Accessing Components","title":"Matrix Representations","text":"Every multicomplex number can be represented as a real matrix:\n\nusing MulticomplexNumbers\n\nz = 1.0 + 2.0*im1\nM = matrep(z)\n\n# Matrix properties\nsize(M)\n\n# The first column contains the components\nM[:, 1]\nflat(z)\n\n# Bicomplex gives 4×4\nw = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\nsize(matrep(w))\n\nThe matrix representation preserves algebra:\n\n# Multiplication via matrices\nw = 3.0 + 4.0*im1\n\nflat(z * w)\n(matrep(z) * matrep(w))[:, 1]\n\n","category":"section"},{"location":"guide/components/#Complex-Array-Views","page":"Accessing Components","title":"Complex Array Views","text":"The ascomplex function views multicomplex arrays as complex arrays. This is particularly useful for extracting specific complex sub-components in NMR applications.\n\nusing MulticomplexNumbers\n\n# Create a bicomplex array\ndata = [Multicomplex(1.0, 2.0, 3.0, 4.0) for i in 1:3]\n\n# View as complex along im1 (extracts real + im1*i components)\nc1 = ascomplex(data, 1)\nsize(c1)  # (2, 3) - the 2 is from 2^(N-1)\n\n# View as complex along im2 (extracts real + im2*i components)\nc2 = ascomplex(data, 2)\nsize(c2)\n\n# Default is highest order\nc_default = ascomplex(data)  # Same as ascomplex(data, 2)","category":"section"},{"location":"guide/components/#Extracting-Specific-Complex-Components","page":"Accessing Components","title":"Extracting Specific Complex Components","text":"For NMR data, you often want to extract specific complex sub-spectra:\n\nusing MulticomplexNumbers\n\n# Create bicomplex data\nz = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\n\n# Extract the real/im1 complex component\n# This gives you a Complex number from the \"real\" part (with respect to im2)\nreal_im1_component = real(z)  # Returns 1.0 + 2.0*im1\n\n# Extract the real/im2 complex component\n# Re-arrange to view im2 as the complex unit\n# For a single number, you can manually extract:\nreal_part = realest(z)  # 1.0\nim2_part = component(z, 3)  # 3.0\n# Complex(real_part, im2_part) would give 1.0 + 3.0im\n\n# For arrays, ascomplex does this automatically\ndata = [Multicomplex(1.0, 2.0, 3.0, 4.0) for _ in 1:4]\ncomplex_view_im1 = ascomplex(data, 1)  # View as complex along im1\ncomplex_view_im2 = ascomplex(data, 2)  # View as complex along im2\n\n","category":"section"},{"location":"guide/components/#Performance-Tips","page":"Accessing Components","title":"Performance Tips","text":"Use flat() once: If you need multiple components, call flat() once and index the result\nAvoid order changes: Mixing orders triggers promotion, which allocates\nPre-allocate arrays: For FFT operations, reuse arrays when possible\nConsider StaticArrays: The internal representation uses SVector, which is stack-allocated\nProfile high orders: Order N uses 2^N components. Order 6 has 64 components per number!\n\n","category":"section"},{"location":"guide/components/#See-Also","page":"Accessing Components","title":"See Also","text":"Creating Numbers: How to create multicomplex numbers\nArithmetic Operations: Mathematical operations\nFFT Operations: Fourier transforms with NMR applications\nAPI Reference: Complete function documentation","category":"section"},{"location":"guide/creating/#creating","page":"Creating Numbers","title":"Creating Multicomplex Numbers","text":"This page explains how to create and work with multicomplex numbers.\n\n","category":"section"},{"location":"guide/creating/#The-Multicomplex-Type","page":"Creating Numbers","title":"The Multicomplex Type","text":"The core type is Multicomplex{T,N,C} where:\n\nT: The base scalar type (must be <:Real, e.g., Float64, BigFloat)\nN: The order (number of imaginary units)\nC: The number of components (always C = 2^N)\n\nusing MulticomplexNumbers\n\n# Examine types\nz = 1.0 + 2.0*im1\ntypeof(z)\n\nw = 1.0 + 2.0*im1 + 3.0*im2\ntypeof(w)","category":"section"},{"location":"guide/creating/#Type-Hierarchy","page":"Creating Numbers","title":"Type Hierarchy","text":"Number\n└── Multicomplex{T,N,C}\n    ├── Multicomplex{Float64,0,1}  # Just a real number\n    ├── Multicomplex{Float64,1,2}  # Complex-like\n    ├── Multicomplex{Float64,2,4}  # Bicomplex\n    ├── Multicomplex{Float64,3,8}  # Tricomplex\n    └── ...\n\n","category":"section"},{"location":"guide/creating/#Using-Imaginary-Units","page":"Creating Numbers","title":"Using Imaginary Units","text":"The package exports im1 through im6:\n\nusing MulticomplexNumbers\n\nim1  # First imaginary unit\nim2  # Second imaginary unit\nim3  # Third imaginary unit\n\n# Build multicomplex numbers by combination\nz = 3.0 + 4.0*im1                           # Order 1\nw = 1.0 + 2.0*im1 + 3.0*im2                 # Order 2 (auto-promoted)\nv = 1.0 + im1 + im2 + im3 + im1*im2*im3    # Order 3\n\n","category":"section"},{"location":"guide/creating/#Direct-Constructors","page":"Creating Numbers","title":"Direct Constructors","text":"using MulticomplexNumbers\n\n# Order 0 (scalar)\nMulticomplex(5.0)\n\n# Order 1 (from two reals)\nMulticomplex(1.0, 2.0)  # = 1 + 2*im1\n\n# Order 1 (from Complex)\nMulticomplex(3.0 + 4.0im)  # = 3 + 4*im1\n\n# Order 2 (from four reals): 1 + 2*im1 + 3*im2 + 4*im1*im2\nMulticomplex(1.0, 2.0, 3.0, 4.0)\n\n# Order 2 (from two Complex numbers)\nMulticomplex(1.0 + 2.0im, 3.0 + 4.0im)  # = (1+2*im1) + (3+4*im1)*im2","category":"section"},{"location":"guide/creating/#Type-Specific-Constructors","page":"Creating Numbers","title":"Type-Specific Constructors","text":"using MulticomplexNumbers\nusing StaticArrays\n\n# Construct with explicit type parameters\nz = Multicomplex{Float64,2,4}(1.0)  # Bicomplex 1.0\n\n# From StaticArrays SVector\nv = SVector(1.0, 2.0, 3.0, 4.0)\nMulticomplex{2}(v)\n\n","category":"section"},{"location":"guide/creating/#Type-Conversions-and-Promotion","page":"Creating Numbers","title":"Type Conversions and Promotion","text":"","category":"section"},{"location":"guide/creating/#Converting-to-Multicomplex","page":"Creating Numbers","title":"Converting to Multicomplex","text":"using MulticomplexNumbers\n\n# Reals promote to multicomplex\nz = 1.0 + 2.0*im1\nz + 3.0  # 3.0 is promoted to Multicomplex\n\n# Complex promotes too\nz + (3.0 + 4.0im)\n\n# Different orders promote to the higher order\na = 1.0 + im1        # Order 1\nb = 2.0 + im2        # Order 2\na + b                 # Result is order 2","category":"section"},{"location":"guide/creating/#Converting-from-Multicomplex","page":"Creating Numbers","title":"Converting from Multicomplex","text":"using MulticomplexNumbers\n\nz = Multicomplex(5.0)  # Order 0\n\n# Convert to real if purely real\nFloat64(z)\n\n# This would error for non-real multicomplex:\n# Float64(1.0 + 2.0*im1)  # InexactError\n\n","category":"section"},{"location":"guide/creating/#Working-with-Higher-Precision","page":"Creating Numbers","title":"Working with Higher Precision","text":"MulticomplexNumbers supports any Real scalar type:\n\nusing MulticomplexNumbers\n\n# BigFloat for high precision\nz = big\"1.0\" + big\"2.0\"*im1\ntypeof(z)\n\n# Compute with high precision\nexp(z)\n\n","category":"section"},{"location":"guide/creating/#See-Also","page":"Creating Numbers","title":"See Also","text":"Arithmetic Operations: Mathematical operations on multicomplex numbers\nAccessing Components: Extract parts and components\nAPI Reference: Complete function documentation","category":"section"},{"location":"guide/fft/#fft-operations","page":"FFT Operations","title":"FFT Operations","text":"This page explains how to perform Fourier transforms on multicomplex data, particularly for NMR spectroscopy applications.\n\n","category":"section"},{"location":"guide/fft/#Setup","page":"FFT Operations","title":"Setup","text":"FFT support requires the FFTW package:\n\nusing MulticomplexNumbers\nusing FFTW  # This loads the FFT extension\n\n","category":"section"},{"location":"guide/fft/#Basic-FFT","page":"FFT Operations","title":"Basic FFT","text":"The fft! function performs in-place FFT along a specific imaginary unit:\n\nusing MulticomplexNumbers\nusing FFTW\n\n# Create bicomplex data\ndata = [Multicomplex(rand(4)...) for _ in 1:64]\n\n# FFT along im1 (treating im1 as the complex unit)\nfft!(data, 1)\n\n# FFT along im2\nfft!(data, 2)\n\n","category":"section"},{"location":"guide/fft/#Unit-Dimension-Association","page":"FFT Operations","title":"Unit-Dimension Association","text":"This is the most common pattern for NMR data processing.\n\nIn multi-dimensional NMR, we typically associate each imaginary unit with a specific array dimension:\n\nusing MulticomplexNumbers\nusing FFTW\n\n# Create 2D NMR data (64 × 32 bicomplex array)\n# Dimension 1 (rows): direct dimension, associated with im1\n# Dimension 2 (cols): indirect dimension, associated with im2\ndata = Array{Multicomplex{Float64, 2, 4}}(undef, 64, 32)\n\n# ... fill with time-domain data ...\n\n# Transform the direct dimension (im1) along dimension 1\nfft!(data, 1, dims=1)\n\n# Transform the indirect dimension (im2) along dimension 2\nfft!(data, 2, dims=2)\n\nThis pattern extends naturally to higher dimensions:\n\nusing MulticomplexNumbers\nusing FFTW\n\n# 3D NMR data (tricomplex)\ndata_3d = Array{Multicomplex{Float64, 3, 8}}(undef, 128, 64, 32)\n\n# ... fill with time-domain data ...\n\n# Transform each dimension with its associated imaginary unit\nfft!(data_3d, 1, dims=1)  # Direct dimension (im1)\nfft!(data_3d, 2, dims=2)  # First indirect (im2)\nfft!(data_3d, 3, dims=3)  # Second indirect (im3)\n\n","category":"section"},{"location":"guide/fft/#Complete-Example:-2D-NMR-Processing","page":"FFT Operations","title":"Complete Example: 2D NMR Processing","text":"using MulticomplexNumbers\nusing FFTW\n\n# Create synthetic 2D NMR signal\nfunction create_2d_nmr_signal(n1, n2, freq1, freq2)\n    signal = Array{Multicomplex{Float64, 2, 4}}(undef, n1, n2)\n\n    for j in 1:n2, i in 1:n1\n        # Time points\n        t1 = (i-1) / n1\n        t2 = (j-1) / n2\n\n        # Oscillating signal with decay\n        # Direct dimension (im1)\n        s1_real = cos(2π * freq1 * t1) * exp(-t1 * 5.0)\n        s1_imag = sin(2π * freq1 * t1) * exp(-t1 * 5.0)\n\n        # Indirect dimension (im2)\n        s2_real = cos(2π * freq2 * t2) * exp(-t2 * 3.0)\n        s2_imag = sin(2π * freq2 * t2) * exp(-t2 * 3.0)\n\n        # Combine as bicomplex\n        signal[i, j] = Multicomplex(\n            s1_real * s2_real,     # real-real\n            s1_imag * s2_real,     # im1 coefficient\n            s1_real * s2_imag,     # im2 coefficient\n            s1_imag * s2_imag      # im1*im2 coefficient\n        )\n    end\n\n    return signal\nend\n\n# Generate signal\nfid = create_2d_nmr_signal(128, 64, 10.0, 15.0)\n\n# Process: FFT both dimensions\nfft!(fid, 1, dims=1)  # Transform direct dimension\nfft!(fid, 2, dims=2)  # Transform indirect dimension\n\n# The peak should appear near indices corresponding to the frequencies\n# (11, 16) for frequencies 10 and 15 out of 128 and 64 points\n\n","category":"section"},{"location":"guide/fft/#Phase-Correction","page":"FFT Operations","title":"Phase Correction","text":"Phase correction is simply multiplication by a phase factor. Use the appropriate imaginary unit for each dimension:\n\nusing MulticomplexNumbers\nusing FFTW\n\n# Create and transform data\nfid = create_2d_nmr_signal(64, 32, 5.0, 10.0)\nfft!(fid, 1, dims=1)\nfft!(fid, 2, dims=2)\n\n# Zero-order phase correction: multiply by exp(imN * θ)\nfid .*= exp(im1 * π/6)   # 30° correction for direct dimension\nfid .*= exp(im2 * π/4)   # 45° correction for indirect dimension\n\n# For first-order (linear) phase correction, apply varying phases across the dimension\nn = size(fid, 1)\nfor i in 1:n\n    θ = π/180 * (i - 1)  # 1° per point\n    fid[i, :] .*= exp(im1 * θ)\nend\n\n","category":"section"},{"location":"guide/fft/#Extracting-Complex-Sub-Components","page":"FFT Operations","title":"Extracting Complex Sub-Components","text":"After processing, you often want to extract specific complex projections:\n\nusing MulticomplexNumbers\nusing FFTW\n\n# Process 2D spectrum\nfid = create_2d_nmr_signal(64, 32, 5.0, 10.0)\nfft!(fid, 1, dims=1)\nfft!(fid, 2, dims=2)\n\n# Extract the real/im1 complex spectrum (traditional F1 dimension)\n# This gives you the spectrum with im1 as the complex unit\nspectrum_im1 = real.(fid)  # Returns Multicomplex{Float64, 1, 2} array\n\n# Extract as actual Complex numbers for plotting/analysis\ncomplex_im1 = ascomplex([spectrum_im1[i, j] for i in 1:64, j in 1:32], 1)\n\n# Extract the real/im2 complex spectrum\n# For each point, we want real + im2*i\nfunction extract_im2_component(data)\n    n1, n2 = size(data)\n    result = Array{Complex{Float64}}(undef, n1, n2)\n    for j in 1:n2, i in 1:n1\n        z = data[i, j]\n        result[i, j] = Complex(realest(z), component(z, 3))\n    end\n    return result\nend\n\ncomplex_im2 = extract_im2_component(fid)\n\n# Or use ascomplex for the full array\n# This creates a view that maps the specified unit to Complex{T}\ncomplex_view = ascomplex(fid, 1)  # Map im1 → im (complex unit)\n\n","category":"section"},{"location":"guide/fft/#Practical-Tips-for-NMR","page":"FFT Operations","title":"Practical Tips for NMR","text":"Dimension-Unit Association: Always associate im1 with the direct (acquisition) dimension, im2 with the first indirect, im3 with the second indirect, etc.\nProcessing Order: Process dimensions in the order that makes sense for your experiment, typically:\nfft!(data, 1, dims=1)  # Direct first\nfft!(data, 2, dims=2)  # Then indirect\nPhase Correction: Apply phase corrections using the appropriate imaginary unit for each dimension:\nDirect dimension: multiply by exp(im1 * θ)\nFirst indirect: multiply by exp(im2 * θ)\nSecond indirect: multiply by exp(im3 * θ)\nMemory Efficiency: FFT is performed in-place, modifying the original array. Make a copy if you need to preserve the original:\nfid_copy = copy(fid)\nfft!(fid_copy, 1, dims=1)\nExtracting Real Spectra: For publication, you typically want the magnitude:\nmagnitude_spectrum = abs.(realest.(fid))\n\n","category":"section"},{"location":"guide/fft/#Advanced:-Custom-FFT-Dimensions","page":"FFT Operations","title":"Advanced: Custom FFT Dimensions","text":"You can apply FFT along specific array dimensions:\n\nusing MulticomplexNumbers\nusing FFTW\n\n# Create 3D array with bicomplex elements\ndata = Array{Multicomplex{Float64, 2, 4}}(undef, 32, 32, 32)\n\n# ... fill with data ...\n\n# FFT along im1, but only along dimension 2 of the array\nfft!(data, 1, dims=2)\n\n# FFT along im2, along both dimensions 1 and 3\nfft!(data, 2, dims=(1, 3))\n\n# Most common: one unit per dimension\nfft!(data, 1, dims=1)  # im1 transforms along array dim 1\nfft!(data, 2, dims=2)  # im2 transforms along array dim 2\n# Dimension 3 could be e.g., different experiments\n\n","category":"section"},{"location":"guide/fft/#See-Also","page":"FFT Operations","title":"See Also","text":"NMR Spectroscopy Applications: Complete NMR workflow examples\nAccessing Components: Extract parts and components\nAPI Reference: Complete function documentation","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"This page provides quick examples demonstrating key features of MulticomplexNumbers.jl.\n\n","category":"section"},{"location":"examples/#Basic-Multicomplex-Algebra","page":"Examples","title":"Basic Multicomplex Algebra","text":"","category":"section"},{"location":"examples/#Imaginary-Units","page":"Examples","title":"Imaginary Units","text":"Multicomplex units im1 through im6 are defined. Each squares to -1:\n\njulia> using MulticomplexNumbers\n\njulia> im1\n0 + 1*im1\n\njulia> im1 * im1\n-1 + 0*im1\n\njulia> im2\n(0 + 0*im1) + (1 + 0*im1)*im2\n\njulia> im2 * im2\n(-1 + 0*im1) + (0 + 0*im1)*im2\n\nProducts of different units commute and create new basis elements:\n\njulia> im1 * im2\n(0 + 0*im1) + (0 + 1*im1)*im2\n\njulia> im1 * im2 == im2 * im1\ntrue\n\nInterestingly, products of distinct units square to +1 (hyperbolic units):\n\njulia> (im1 * im2)^2\n(1 + 0*im1) + (0 + 0*im1)*im2","category":"section"},{"location":"examples/#Creating-Numbers","page":"Examples","title":"Creating Numbers","text":"julia> z = 1.0 + 2.0*im1  # Complex (order 1)\n1.0 + 2.0*im1\n\njulia> w = 3.0 + 4.0*im1 + 5.0*im2 + 6.0*im1*im2  # Bicomplex (order 2)\n(3.0 + 4.0*im1) + (5.0 + 6.0*im1)*im2\n\njulia> Multicomplex(1.0, 2.0)  # From components\n1.0 + 2.0*im1\n\njulia> Multicomplex(1+2im)  # From Complex\n1 + 2*im1\n\n","category":"section"},{"location":"examples/#Arithmetic","page":"Examples","title":"Arithmetic","text":"","category":"section"},{"location":"examples/#Basic-Operations","page":"Examples","title":"Basic Operations","text":"julia> a = 1.0 + 2.0*im1;\n\njulia> b = 3.0 + 4.0*im1;\n\njulia> a + b\n4.0 + 6.0*im1\n\njulia> a * b\n-5.0 + 10.0*im1\n\njulia> a / b\n0.44 + 0.08*im1","category":"section"},{"location":"examples/#Powers-and-Transcendentals","page":"Examples","title":"Powers and Transcendentals","text":"julia> z = 1.0 + 1.0*im1;\n\njulia> z^2\n0.0 + 2.0*im1\n\njulia> exp(z)\n1.4686939399158851 + 2.2873552871788423*im1\n\njulia> log(z)\n0.34657359027997264 + 0.7853981633974483*im1\n\njulia> sqrt(z)\n1.0986841134678098 + 0.45508986056222733*im1\n\n","category":"section"},{"location":"examples/#Component-Access","page":"Examples","title":"Component Access","text":"","category":"section"},{"location":"examples/#Extracting-Parts","page":"Examples","title":"Extracting Parts","text":"julia> z = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2;\n\njulia> real(z)  # Order N-1 real part\n1.0 + 2.0*im1\n\njulia> imag(z)  # Order N-1 imaginary part\n3.0 + 4.0*im1\n\njulia> flat(z)  # All components\n4-element StaticArraysCore.SVector{4, Float64} with indices SOneTo(4):\n 1.0\n 2.0\n 3.0\n 4.0\n\njulia> realest(z)  # First component\n1.0\n\njulia> component(z, 4)  # Specific component (im1*im2 coefficient)\n4.0","category":"section"},{"location":"examples/#Order-and-Properties","page":"Examples","title":"Order and Properties","text":"julia> order(1.0 + im1)\n1\n\njulia> order(1.0 + im1 + im2)\n2\n\njulia> isreal(5.0 + 0.0*im1)\ntrue\n\njulia> isreal(1.0 + 2.0*im1)\nfalse\n\n","category":"section"},{"location":"examples/#Matrix-Representation","page":"Examples","title":"Matrix Representation","text":"Every multicomplex number has an equivalent matrix:\n\njulia> z = 1.0 + 2.0*im1;\n\njulia> M = matrep(z)\n2×2 StaticArraysCore.SMatrix{2, 2, Float64, 4} with indices SOneTo(2)×SOneTo(2):\n 1.0  -2.0\n 2.0   1.0\n\nThe matrix representation preserves algebra:\n\njulia> w = 3.0 + 4.0*im1;\n\njulia> flat(z * w)\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n -5.0\n 10.0\n\njulia> (matrep(z) * matrep(w))[:, 1]\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n -5.0\n 10.0\n\n","category":"section"},{"location":"examples/#Numerical-Differentiation","page":"Examples","title":"Numerical Differentiation","text":"","category":"section"},{"location":"examples/#First-Derivative","page":"Examples","title":"First Derivative","text":"julia> f(x) = x^3;\n\njulia> x = 2.0;\n\njulia> h = 1e-100;\n\njulia> derivative = imag(f(x + h*im1)) / h\n12.0\n\njulia> # Exact: f'(x) = 3x² = 12","category":"section"},{"location":"examples/#Second-Derivative","page":"Examples","title":"Second Derivative","text":"julia> f(x) = x^4;\n\njulia> x = 2.0;\n\njulia> h = 1e-50;\n\njulia> result = f(x + h*im1 + h*im2);\n\njulia> second_derivative = component(result, 4) / h^2\n48.0\n\njulia> # Exact: f''(x) = 12x² = 48\n\n","category":"section"},{"location":"examples/#Complex-Views","page":"Examples","title":"Complex Views","text":"Convert multicomplex arrays to complex arrays:\n\njulia> data = [Multicomplex(1.0, 2.0, 3.0, 4.0)];\n\njulia> c = ascomplex(data, 1);\n\njulia> size(c)\n(2, 1)\n\njulia> c[1]\n1.0 + 2.0im\n\njulia> c[2]\n3.0 + 4.0im\n\n","category":"section"},{"location":"examples/#Type-Promotions","page":"Examples","title":"Type Promotions","text":"Different orders automatically promote:\n\njulia> a = 1.0 + im1;  # Order 1\n\njulia> b = 2.0 + im2;  # Order 2\n\njulia> c = a + b;  # Promoted to order 2\n\njulia> order(c)\n2\n\nScalars and Complex promote to multicomplex:\n\njulia> z = 1.0 + im1;\n\njulia> z + 5.0\n6.0 + 1.0*im1\n\njulia> z + (2.0 + 3.0im)\n3.0 + 4.0*im1\n\n","category":"section"},{"location":"examples/#FFT-(requires-FFTW)","page":"Examples","title":"FFT (requires FFTW)","text":"using MulticomplexNumbers\nusing FFTW\n\n# Create bicomplex signal\nsignal = [Multicomplex(cos(2π*k/64), sin(2π*k/64), 0.0, 0.0) for k in 0:63]\n\n# FFT along im1\nfft!(signal, 1)\n\n# Peak at frequency 1\nabs(realest(signal[2]))  # Should be large\n\n","category":"section"},{"location":"examples/#High-Precision","page":"Examples","title":"High Precision","text":"julia> z = big\"1.0\" + big\"2.0\" * im1;\n\njulia> typeof(z)\nMulticomplex{BigFloat, 1, 2}\n\njulia> exp(z)\n-1.131204383756813... + 2.471726672004818...*im1\n\n","category":"section"},{"location":"examples/#Quick-Reference","page":"Examples","title":"Quick Reference","text":"Task Code\nCreate order 1 1.0 + 2.0*im1\nCreate order 2 1.0 + 2.0*im1 + 3.0*im2\nGet components flat(z)\nGet order order(z)\n1st derivative imag(f(x + h*im1)) / h\n2nd derivative component(f(x + h*im1 + h*im2), 4) / h²\nMatrix form matrep(z)\nAs complex ascomplex(data, unit)","category":"section"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/#Introduction","page":"Background","title":"Introduction","text":"MulticomplexNumbers.jl provides a Julia implementation of multicomplex numbers. These numbers are a generalisation of complex numbers, recursively defined to contain multiple imaginary numbers, i_1, i_2 etc. Unlike Clifford algebras, these numbers commute, i.e. i_1i_2=i_2i_1.","category":"section"},{"location":"background/#Algebra-of-the-multicomplex-numbers","page":"Background","title":"Algebra of the multicomplex numbers","text":"","category":"section"},{"location":"background/#Recursive-Definition","page":"Background","title":"Recursive Definition","text":"Multicomplex numbers are built recursively from real numbers:\n\nmathbbC_0 = mathbbR\n\nmathbbC_n = mathbbC_n-1 + i_n mathbbC_n-1\n\nThis means:\n\nmathbbC_0: Real numbers (1 component)\nmathbbC_1 = mathbbR + i_1mathbbR: Complex numbers (2 components)\nmathbbC_2 = mathbbC_1 + i_2mathbbC_1: Bicomplex numbers (4 components)\nmathbbC_3 = mathbbC_2 + i_3mathbbC_2: Tricomplex numbers (8 components)\nmathbbC_n: Has 2^n real components","category":"section"},{"location":"background/#Fundamental-Properties","page":"Background","title":"Fundamental Properties","text":"Each imaginary unit squares to negative one:\n\ni_k^2 = -1 quad textfor all  k geq 1\n\nIn code:\n\nusing MulticomplexNumbers\n\nim1 * im1\nim2 * im2\n\nCrucially, imaginary units commute with each other:\n\ni_j i_k = i_k i_j quad textfor all  j k\n\nThis commutativity distinguishes multicomplex numbers from quaternions and other hypercomplex systems where imaginary units anticommute.\n\n# Commutativity\nim1 * im2 == im2 * im1\n\nInterestingly, products of distinct imaginary units square to positive one:\n\n(i_j i_k)^2 = i_j i_k i_j i_k = i_j^2 i_k^2 = (-1)(-1) = +1 quad text(when  j neq k text)\n\n# Hyperbolic units\n(im1 * im2)^2\n\nThis reveals an important property: products like i_1 i_2 are hyperbolic units (they square to +1), not elliptic units (which square to -1). This is why mathbbC_n for n geq 2 contains zero divisors.","category":"section"},{"location":"background/#Component-Representation","page":"Background","title":"Component Representation","text":"A general multicomplex number m in mathbbC_n can be written as:\n\nFor n = 1 (complex):\n\nm = a + b cdot i_1\n\nFor n = 2 (bicomplex):\n\nm = a + b cdot i_1 + c cdot i_2 + d cdot i_1 i_2\n\nFor n = 3 (tricomplex):\n\nm = a + b cdot i_1 + c cdot i_2 + d cdot i_1 i_2 + e cdot i_3 + f cdot i_1 i_3 + g cdot i_2 i_3 + h cdot i_1 i_2 i_3\n\nIn general, mathbbC_n has 2^n basis elements formed by all possible products of the imaginary units 1 i_1 i_2 ldots i_n and their combinations.","category":"section"},{"location":"background/#Recursive-Structure","page":"Background","title":"Recursive Structure","text":"Any multicomplex number m in mathbbC_n can be uniquely written as:\n\nm = a + i_n cdot b\n\nwhere a b in mathbbC_n-1 are called the \"real\" and \"imaginary\" parts (with respect to i_n).\n\nThis recursive structure is central to the implementation: the real and imag functions return multicomplex numbers of order n-1.\n\nusing MulticomplexNumbers\n\nz = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\n\n# Recursive structure: z = real(z) + im2 * imag(z)\nreal(z)   # Order 1 (with respect to im2)\nimag(z)   # Order 1","category":"section"},{"location":"background/#Matrix-Representations","page":"Background","title":"Matrix Representations","text":"","category":"section"},{"location":"background/#The-Matrix-Homomorphism","page":"Background","title":"The Matrix Homomorphism","text":"Every multicomplex number can be faithfully represented as a real matrix. This representation is a ring homomorphism that preserves addition and multiplication.\n\nFor mathbbC_1 (complex numbers), the familiar 2×2 representation:\n\na + b cdot i_1 mapsto beginpmatrix a  -b  b  a endpmatrix\n\nusing MulticomplexNumbers\n\nz = 3.0 + 4.0*im1\nmatrep(z)\n\nFor mathbbC_2 (bicomplex numbers), a 4×4 matrix where the structure is built recursively:\n\n(a + b cdot i_1) + (c + d cdot i_1) cdot i_2 mapsto beginpmatrix M(a + b cdot i_1)  -M(c + d cdot i_1)  M(c + d cdot i_1)  M(a + b cdot i_1) endpmatrix\n\nwhere M(cdot) denotes the matrix representation.\n\nw = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\nmatrep(w)","category":"section"},{"location":"background/#Recursive-Construction","page":"Background","title":"Recursive Construction","text":"For m = a + i_n cdot b in mathbbC_n with a b in mathbbC_n-1:\n\nM(m) = beginpmatrix M(a)  -M(b)  M(b)  M(a) endpmatrix\n\nThis 2^n times 2^n matrix has the property that the first column contains all 2^n components of the multicomplex number.","category":"section"},{"location":"background/#Why-Matrix-Representation?","page":"Background","title":"Why Matrix Representation?","text":"The matrix representation enables:\n\nMultiplication: m_1 times m_2 computed via M(m_1) times M(m_2)\nDivision: m_1  m_2 computed via M(m_1) times M(m_2)^-1\nPowers: m^p computed via matrix power\nTranscendental functions: exp(m), log(m), sqrtm via matrix functions\n\nThe result is extracted from the first column of the resulting matrix.\n\nusing MulticomplexNumbers\nusing LinearAlgebra\n\nz = 1.0 + 0.5*im1\n\n# Verify: multiplication via matrices\nw = 2.0 + 0.3*im1\nz * w\n\n# Compare to matrix multiplication\nM_z = matrep(z)\nM_w = matrep(w)\nM_product = M_z * M_w\nM_product[:, 1]  # First column contains the components\n\n# Transcendental functions use matrix functions\nexp(z)\nexp(M_z)[:, 1]  # Same result","category":"section"},{"location":"background/#Zero-Divisors","page":"Background","title":"Zero Divisors","text":"Unlike complex numbers, bicomplex and higher multicomplex numbers have zero divisors: non-zero elements whose product is zero.\n\nFor example, in mathbbC_2:\n\n(1 + i_1 i_2)(1 - i_1 i_2) = 1 - (i_1 i_2)^2 = 1 - 1 = 0\n\nThis means:\n\nDivision by some non-zero elements is undefined (singular matrix)\nmathbbC_n for n geq 2 is not a division algebra","category":"section"},{"location":"background/#Arithmetic","page":"Background","title":"Arithmetic","text":"","category":"section"},{"location":"background/#Addition-and-Subtraction","page":"Background","title":"Addition and Subtraction","text":"Component-wise operations:\n\n(a + b cdot i_1) + (c + d cdot i_1) = (a + c) + (b + d) cdot i_1\n\nThis extends naturally to all orders.\n\nusing MulticomplexNumbers\n\na = 1.0 + 2.0*im1\nb = 3.0 + 4.0*im1\na + b","category":"section"},{"location":"background/#Multiplication","page":"Background","title":"Multiplication","text":"Multiplication follows from the algebraic rules. For complex numbers:\n\n(a + b cdot i_1)(c + d cdot i_1) = (ac - bd) + (ad + bc) cdot i_1\n\na = 1.0 + 2.0*im1\nb = 3.0 + 4.0*im1\na * b\n\nFor bicomplex and higher orders, multiplication is most efficiently computed via the matrix representation.","category":"section"},{"location":"background/#Conjugation","page":"Background","title":"Conjugation","text":"Multicomplex conjugation inverts the sign of the highest imaginary component:\n\noverlinem = overlinea + i_n cdot b = a - i_n cdot b\n\nwhere a b in mathbbC_n-1.\n\nNote: This is different from complex conjugation applied to all imaginary units.\n\nusing MulticomplexNumbers\n\nz = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\nconj(z)  # Negates the im2 component","category":"section"},{"location":"background/#Norm","page":"Background","title":"Norm","text":"The Euclidean norm is defined as:\n\nm = sqrtsum_k=1^2^n c_k^2\n\nwhere c_k are the real components of the multicomplex number.\n\nusing MulticomplexNumbers\nusing LinearAlgebra\n\nz = 3.0 + 4.0*im1\nnorm(z)  # sqrt(3² + 4²) = 5\nabs(z)   # Same as norm","category":"section"},{"location":"background/#Applications","page":"Background","title":"Applications","text":"","category":"section"},{"location":"background/#Numerical-Differentiation","page":"Background","title":"Numerical Differentiation","text":"The primary application of multicomplex numbers is high-order numerical differentiation. The multicomplex step method extends the complex step derivative to compute higher-order derivatives with machine precision accuracy.\n\nFor a function f extended to multicomplex arguments:\n\nf(x + h cdot i_1) = f(x) + h cdot f(x) cdot i_1 + O(h^2)\n\nThe first derivative is extracted from the i_1 component:\n\nf(x) approx fractextIm_1f(x + h cdot i_1)h\n\nThis avoids subtractive cancellation errors that plague finite difference methods.\n\nFor second derivatives using bicomplex numbers:\n\nf(x) approx fractextcomponent_i_1 i_2f(x + h cdot i_1 + h cdot i_2)h^2","category":"section"},{"location":"background/#Signal-Processing","page":"Background","title":"Signal Processing","text":"Multicomplex Fourier transforms enable processing of signals with multiple independent phase components, useful in certain NMR spectroscopy applications.","category":"section"},{"location":"background/#References","page":"Background","title":"References","text":"NIST report on multicomplex algebra: https://nvlpubs.nist.gov/nistpubs/jres/126/jres.126.033.pdf\nCasado & Hewson (2020): Algorithm 1008: Multicomplex Number Class for Matlab. ACM Trans Math Softw. http://dx.doi.org/10.1145/3378542\nNIST C++ implementation: https://github.com/usnistgov/multicomplex","category":"section"},{"location":"#MulticomplexNumbers.jl","page":"Home","title":"MulticomplexNumbers.jl","text":"A Julia package for representing multicomplex numbers and performing multicomplex algebra.","category":"section"},{"location":"#What-are-Multicomplex-Numbers?","page":"Home","title":"What are Multicomplex Numbers?","text":"Multicomplex numbers are a generalization of complex numbers, recursively defined to contain multiple imaginary units (i_1, i_2, i_3, ...). Unlike quaternions and Clifford algebras, these imaginary units commute: i_1 i_2 = i_2 i_1.\n\nmathbbC_0 = mathbbR quad mathbbC_n = mathbbC_n-1 + i_n mathbbC_n-1\n\nOrder Name Components Example\n0 Real 1 5.0\n1 Complex 2 1 + 2i₁\n2 Bicomplex 4 1 + 2i₁ + 3i₂ + 4i₁i₂\n3 Tricomplex 8 1 + 2i₁ + 3i₂ + 4i₃ + ...","category":"section"},{"location":"#Key-Applications","page":"Home","title":"Key Applications","text":"","category":"section"},{"location":"#Multi-dimensional-NMR-Spectroscopy","page":"Home","title":"Multi-dimensional NMR Spectroscopy","text":"Bicomplex and higher-order multicomplex numbers naturally represent multi-dimensional NMR data where each dimension has its own imaginary component:\n\nusing MulticomplexNumbers\nusing FFTW\n\n# 2D NMR: bicomplex numbers (im1 = direct, im2 = indirect)\n# Create bicomplex FID where each dimension has real + imaginary components\nfid = Array{Multicomplex{Float64, 2, 4}}(undef, 128, 64)\n# ... load your NMR data ...\n\n# Transform each dimension with its associated imaginary unit\nfft!(fid, 1, dims=1)  # Direct dimension (im1)\nfft!(fid, 2, dims=2)  # Indirect dimension (im2)\n\n# Phase correction using appropriate imaginary units\nfid .*= exp(im1 * 0.1)  # Correct direct dimension\nfid .*= exp(im2 * 0.2)  # Correct indirect dimension","category":"section"},{"location":"#High-Precision-Numerical-Differentiation","page":"Home","title":"High-Precision Numerical Differentiation","text":"The multicomplex step method computes derivatives with machine precision, avoiding the subtractive cancellation errors that limit finite difference methods:\n\nusing MulticomplexNumbers\n\n# First derivative with machine precision\nf(x) = sin(x) * exp(-x^2)\nh = 1e-100  # Impossibly small for finite differences!\nx = 0.5 + h*im1\nderivative = imag(f(x)) / h  # Exact to ~15 digits","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using Pkg\nPkg.add(\"MulticomplexNumbers\")\n\nusing MulticomplexNumbers\n\n# Create multicomplex numbers\nz = 1.0 + 2.0*im1                    # Complex (order 1)\nw = 1.0 + 2.0*im1 + 3.0*im2          # Bicomplex (order 2)\n\n# Arithmetic\nz * w\nexp(w)\nsqrt(w)\n\n# Numerical differentiation\nh = 1e-100\nx = 2.0 + h*im1\nf_prime = imag(x^3) / h  # = 12.0 (exact!)","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Full arithmetic: +, -, *, /, ^, exp, log, sqrt\nImaginary units: im1 through im6 for orders 1-6\nType-stable: Uses StaticArrays for stack-allocated, cache-friendly storage\nFFT support: In-place multicomplex FFT via FFTW extension\nHigh precision: Works with BigFloat and other Real types\nJulia integration: Proper Number subtype with promotion rules","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Pages = [\n    \"getting-started.md\",\n    \"background.md\",\n    \"guide/creating.md\",\n    \"guide/arithmetic.md\",\n    \"guide/components.md\",\n    \"guide/fft.md\",\n    \"applications/nmr.md\",\n    \"applications/differentiation.md\",\n    \"examples.md\",\n    \"api.md\"\n]\nDepth = 2\n\n","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"MulticomplexNumbers.jl is a registered package:\n\nusing Pkg\nPkg.add(\"MulticomplexNumbers\")\n\nFor FFT support:\n\nPkg.add(\"FFTW\")\n\n","category":"section"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"NMRTools.jl: A library for handling NMR data in Julia (uses this package)\nDualNumbers.jl: Dual numbers for first-order automatic differentiation\nForwardDiff.jl: Forward mode automatic differentiation\nHyperDualNumbers.jl: Hyper-dual numbers for second derivatives\nCliffordAlgebras.jl: Clifford and geometric algebras\n\n","category":"section"},{"location":"#References","page":"Home","title":"References","text":"NIST Report: Bell, I. H., Deiters, U. K. (2021). \"Precise Numerical Differentiation of Thermodynamic Functions with Multicomplex Variables.\" NIST J. Res. 126:033\nACM Algorithm: Casado, J. M. V., Hewson, R. (2020). \"Algorithm 1008: Multicomplex Number Class for Matlab.\" ACM Trans. Math. Softw. 46:1-26. doi:10.1145/3378542\nNIST Implementation: github.com/usnistgov/multicomplex - C++ multicomplex library\nOriginal Method: Lantoine, G., Russell, R. P., Dargent, T. (2012). \"Using Multicomplex Variables for Automatic Computation of High-order Derivatives.\" ACM Trans. Math. Softw. 38(3):16. doi:10.1145/2168773.2168774\n\n","category":"section"},{"location":"#Authors","page":"Home","title":"Authors","text":"Chris Waudby, UCL School of Pharmacy, London (UK)","category":"section"},{"location":"#Citing","page":"Home","title":"Citing","text":"If you find this package useful, please cite:\n\nWaudby, C. A. (2022). MulticomplexNumbers.jl. github.com/waudbygroup/MulticomplexNumbers.jl","category":"section"},{"location":"#License","page":"Home","title":"License","text":"MulticomplexNumbers.jl is licensed under the MIT license; see LICENSE for the full license text.","category":"section"}]
}
