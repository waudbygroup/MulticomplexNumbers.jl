var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page provides complete documentation for all exported types and functions.\n\n","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Constants","page":"API Reference","title":"Constants","text":"","category":"section"},{"location":"api/#Imaginary-Units","page":"API Reference","title":"Imaginary Units","text":"The package exports imaginary units im1 through im6 for conveniently constructing multicomplex numbers.\n\nAdditional units im2, im3, im4, im5, and im6 follow the same pattern for higher orders.\n\n","category":"section"},{"location":"api/#Component-Access","page":"API Reference","title":"Component Access","text":"","category":"section"},{"location":"api/#Order","page":"API Reference","title":"Order","text":"","category":"section"},{"location":"api/#Flat-Components","page":"API Reference","title":"Flat Components","text":"","category":"section"},{"location":"api/#Individual-Components","page":"API Reference","title":"Individual Components","text":"","category":"section"},{"location":"api/#Real-Component","page":"API Reference","title":"Real Component","text":"","category":"section"},{"location":"api/#Representations","page":"API Reference","title":"Representations","text":"","category":"section"},{"location":"api/#Matrix-Representation","page":"API Reference","title":"Matrix Representation","text":"","category":"section"},{"location":"api/#Complex-View","page":"API Reference","title":"Complex View","text":"","category":"section"},{"location":"api/#Standard-Functions","page":"API Reference","title":"Standard Functions","text":"The following Base functions are extended for multicomplex numbers:","category":"section"},{"location":"api/#Real-and-Imaginary-Parts","page":"API Reference","title":"Real and Imaginary Parts","text":"real(m::Multicomplex): Returns the real part with respect to the highest imaginary unit (order N-1)\nimag(m::Multicomplex): Returns the imaginary part with respect to the highest imaginary unit (order N-1)","category":"section"},{"location":"api/#Arithmetic","page":"API Reference","title":"Arithmetic","text":"+, -: Addition and subtraction (element-wise on components)\n*: Multiplication (via matrix representation)\n/: Division (via matrix representation)\n^: Power (integer and real exponents)\ninv(m): Multiplicative inverse","category":"section"},{"location":"api/#Transcendental-Functions","page":"API Reference","title":"Transcendental Functions","text":"exp(m): Exponential\nlog(m): Natural logarithm\nsqrt(m): Square root","category":"section"},{"location":"api/#Trigonometric-Functions","page":"API Reference","title":"Trigonometric Functions","text":"sin(m): Sine\ncos(m): Cosine\ntan(m): Tangent\ncot(m): Cotangent\nsec(m): Secant\ncsc(m): Cosecant","category":"section"},{"location":"api/#Hyperbolic-Functions","page":"API Reference","title":"Hyperbolic Functions","text":"sinh(m): Hyperbolic sine\ncosh(m): Hyperbolic cosine\ntanh(m): Hyperbolic tangent\ncoth(m): Hyperbolic cotangent\nsech(m): Hyperbolic secant\ncsch(m): Hyperbolic cosecant","category":"section"},{"location":"api/#Inverse-Trigonometric-Functions","page":"API Reference","title":"Inverse Trigonometric Functions","text":"asin(m): Arcsine\nacos(m): Arccosine\natan(m): Arctangent\nacot(m): Arccotangent\nasec(m): Arcsecant\nacsc(m): Arccosecant","category":"section"},{"location":"api/#Inverse-Hyperbolic-Functions","page":"API Reference","title":"Inverse Hyperbolic Functions","text":"asinh(m): Inverse hyperbolic sine\nacosh(m): Inverse hyperbolic cosine\natanh(m): Inverse hyperbolic tangent\nacoth(m): Inverse hyperbolic cotangent\nasech(m): Inverse hyperbolic secant\nacsch(m): Inverse hyperbolic cosecant","category":"section"},{"location":"api/#Conjugation-and-Norms","page":"API Reference","title":"Conjugation and Norms","text":"conj(m): Multicomplex conjugation (negates highest imaginary part)\nabs(m): Absolute value (Euclidean norm)\nabs2(m): Squared absolute value","category":"section"},{"location":"api/#Comparisons-and-Properties","page":"API Reference","title":"Comparisons and Properties","text":"==, isequal: Equality comparison\nisreal(m): Check if all imaginary components are zero\nisinteger(m): Check if real and integer-valued\nisfinite(m): Check if all components are finite\nisnan(m): Check if any component is NaN\nisinf(m): Check if any component is infinite\niszero(m): Check if all components are zero\nisone(m): Check if equal to multiplicative identity","category":"section"},{"location":"api/#Type-Utilities","page":"API Reference","title":"Type Utilities","text":"zero(Multicomplex{T,N,C}): Additive identity\none(Multicomplex{T,N,C}): Multiplicative identity\nfloat(Multicomplex{T,N,C}): Convert to floating-point base type\n\n","category":"section"},{"location":"api/#Multicomplex-Specific-Operations","page":"API Reference","title":"Multicomplex-Specific Operations","text":"","category":"section"},{"location":"api/#Fold-Operator","page":"API Reference","title":"Fold Operator","text":"The fold operator multiplies a multicomplex number by its conjugate, reducing the order by one.","category":"section"},{"location":"api/#Abient-Numbers","page":"API Reference","title":"Abient Numbers","text":"A multicomplex number is \"abient\" if it becomes zero after sufficiently many foldings. This property arises because multicomplex numbers are not a composition algebra.\n\n","category":"section"},{"location":"api/#Random-Number-Generation","page":"API Reference","title":"Random Number Generation","text":"The package supports random number generation for multicomplex numbers:","category":"section"},{"location":"api/#Uniform-Distribution","page":"API Reference","title":"Uniform Distribution","text":"rand([rng], Multicomplex{T,N,C})\n\nGenerates a random multicomplex number with components drawn from the default distribution for type T.\n\nExample:\n\njulia> rand(Multicomplex{Float64,1,2})\n0.234 + 0.891*im1\n\njulia> rand(Multicomplex{Float64,2,4})\n(0.123 + 0.456*im1) + (0.789 + 0.234*im1)*im2","category":"section"},{"location":"api/#Normal-Distribution","page":"API Reference","title":"Normal Distribution","text":"randn([rng], Multicomplex{T,N,C}) where {T<:AbstractFloat}\n\nGenerates a random multicomplex number with components drawn from a standard normal distribution. Only available for floating-point types.\n\nExample:\n\njulia> randn(Multicomplex{Float64,1,2})\n-0.543 + 1.234*im1\n\njulia> randn(Multicomplex{Float64,2,4})\n(0.891 - 0.234*im1) + (-1.567 + 0.432*im1)*im2\n\n","category":"section"},{"location":"api/#FFT-Support-(FFTW-Extension)","page":"API Reference","title":"FFT Support (FFTW Extension)","text":"When FFTW.jl is loaded, the following function becomes available:","category":"section"},{"location":"api/#In-place-FFT","page":"API Reference","title":"In-place FFT","text":"fft!(A::AbstractArray{<:Multicomplex}, unit::Integer)\nfft!(A::AbstractArray{<:Multicomplex}, unit::Integer, dims)\n\nPerforms an in-place FFT on a multicomplex array, treating unit as the imaginary unit for the complex FFT.\n\nArguments:\n\nA: Array of multicomplex numbers\nunit: Which imaginary unit to use (1 for im1, 2 for im2, etc.)\ndims: Dimensions along which to compute the FFT (optional, defaults to all)\n\nSupported orders: N = 1, 2, 3, 4\n\nExample:\n\nusing MulticomplexNumbers\nusing FFTW\n\ndata = [Multicomplex(rand(4)...) for _ in 1:64]\nfft!(data, 1)  # FFT along im1\nfft!(data, 2)  # FFT along im2\n\n","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"Pages = [\"api.md\"]","category":"section"},{"location":"api/#MulticomplexNumbers.Multicomplex","page":"API Reference","title":"MulticomplexNumbers.Multicomplex","text":"Multicomplex{T,N,C}(value)\n\nDefines a multicomplex number ℂ_N, over base field T, having C=2^N components specified in static vector value.\n\nInput:     value::SVector{C, T})\n\n\n\n\n\n","category":"type"},{"location":"api/#MulticomplexNumbers.im1","page":"API Reference","title":"MulticomplexNumbers.im1","text":"im1, im2, im3, im4, im5, im6\n\nThe imaginary units, up to dimension 6.\n\n\n\n\n\n","category":"constant"},{"location":"api/#MulticomplexNumbers.order","page":"API Reference","title":"MulticomplexNumbers.order","text":"Order of the multicomplex number is the number of imaginary units\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.flat","page":"API Reference","title":"MulticomplexNumbers.flat","text":"Get components as a vector\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.component","page":"API Reference","title":"MulticomplexNumbers.component","text":"Utility function to extract a real-valued component from a multicomplex number\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.realest","page":"API Reference","title":"MulticomplexNumbers.realest","text":"Extract the 'most real' component\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.matrep","page":"API Reference","title":"MulticomplexNumbers.matrep","text":"matrix representation of a multicomplex number\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.ascomplex","page":"API Reference","title":"MulticomplexNumbers.ascomplex","text":"ascomplex(A::AbstractArray{M}, [unit])\n\nReturns a view of the multicomplex input array A as an array of complex numbers, mapping i(unit) -> im. If a unit is not supplied, defaults to the highest order.\n\nIf A has size (m, n, ...) with multicomplex numbers of dimension N, then the output will have size (2^(N-1), m, n, ...).\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.fold","page":"API Reference","title":"MulticomplexNumbers.fold","text":"fold(m::Multicomplex{T,N})\n\nFolding operation that multiplies a multicomplex number by its conjugate.\n\nWith w ∈ ℂₙ₊₁, fold(w) = w × conj(w) = conj(w) × w ∈ ℂₙ.\n\nThe fold operation reduces the order by 1:\n\nfold(ℂₙ) → ℂₙ₋₁\nfold(ℂ₁) → ℂ₀ (real numbers)\nfold(ℂ₀) → ℂ₀ (squaring)\n\nExamples\n\njulia> fold(1 + im1)\nMulticomplex(2.0)\n\njulia> fold(1 + im1*im2)  # (1 + i₁i₂)(1 - i₁i₂) = 0\nMulticomplex(0.0, 0.0)\n\nReferences\n\nSometimes the fold of a nonzero number turns out to be zero; for example, (1 + i₁i₂)(1 - i₁i₂) = 0. This illustrates that the norm is not always preserved under multiplication, thus the multicomplex numbers are not a composition algebra.\n\n\n\n\n\n","category":"function"},{"location":"api/#MulticomplexNumbers.isabient","page":"API Reference","title":"MulticomplexNumbers.isabient","text":"isabient(m::Multicomplex; atol=0, rtol=atol>0 ? 0 : √eps)\n\nDetermine if a multicomplex number is abient.\n\nA multicomplex number is abient (from a Latin participle meaning \"going away\") if after sufficiently many foldings it becomes zero. After N foldings, an ℂₙ multicomplex number becomes a real number; if it turns out to be zero, the multicomplex number is abient.\n\nArguments\n\nm::Multicomplex: The multicomplex number to test\natol::Real=0: Absolute tolerance for zero comparison\nrtol::Real: Relative tolerance (defaults to √eps if atol=0)\n\nExamples\n\njulia> isabient(1 + im1)\nfalse\n\njulia> isabient(1 + im1*im2)  # (1 + i₁i₂) is abient\ntrue\n\nReferences\n\nNot to be confused with \"ambient\". This concept arises because multicomplex numbers are not a composition algebra - the norm is not always preserved under multiplication.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This guide will help you get up and running with MulticomplexNumbers.jl quickly.","category":"section"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"MulticomplexNumbers.jl is a registered Julia package. Install it using Julia's package manager:\n\nusing Pkg\nPkg.add(\"MulticomplexNumbers\")\n\nOr in the package REPL (press ]):\n\npkg> add MulticomplexNumbers","category":"section"},{"location":"getting-started/#Optional:-FFT-Support","page":"Getting Started","title":"Optional: FFT Support","text":"For Fourier transform capabilities, also install FFTW:\n\nPkg.add(\"FFTW\")","category":"section"},{"location":"getting-started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"using MulticomplexNumbers","category":"section"},{"location":"getting-started/#Creating-Multicomplex-Numbers","page":"Getting Started","title":"Creating Multicomplex Numbers","text":"The package provides imaginary units im1 through im6 for constructing multicomplex numbers:\n\n# Order 1: Complex numbers (2 components)\nz1 = 1.0 + 2.0*im1\n\n# Order 2: Bicomplex numbers (4 components)\nz2 = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\n\n# Order 3: Tricomplex numbers (8 components)\nz3 = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im3\n\nYou can also use direct constructors:\n\n# From real components\nMulticomplex(1.0, 2.0)           # = 1 + 2*im1\nMulticomplex(1.0, 2.0, 3.0, 4.0) # = 1 + 2*im1 + 3*im2 + 4*im1*im2\n\n# From Complex numbers\nMulticomplex(1.0 + 2.0im)        # = 1 + 2*im1","category":"section"},{"location":"getting-started/#Key-Properties","page":"Getting Started","title":"Key Properties","text":"Each imaginary unit squares to -1:\n\nim1 * im1\nim2 * im2\n\nUnlike quaternions, multicomplex units commute:\n\nim1 * im2 == im2 * im1\n\nHowever, the product of different units is hyperbolic (squares to +1):\n\n(im1 * im2)^2","category":"section"},{"location":"getting-started/#Arithmetic-Operations","page":"Getting Started","title":"Arithmetic Operations","text":"All standard operations are supported:\n\na = 1.0 + 2.0*im1 + 3.0*im2\nb = 2.0 + 1.0*im1 - 1.0*im2\n\n# Addition and subtraction\na + b\na - b\n\n# Multiplication and division\na * b\na / b\n\n# Powers and transcendental functions\na^2\nexp(a)\nlog(a)\nsqrt(a)","category":"section"},{"location":"getting-started/#Extracting-Components","page":"Getting Started","title":"Extracting Components","text":"z = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\n\n# Real and imaginary parts (returns multicomplex of order N-1)\nreal(z)\nimag(z)\n\n# Get all components as a vector\nflat(z)\n\n# Get the \"most real\" component (first component)\nrealest(z)\n\n# Get a specific component by index\ncomponent(z, 2)  # The im1 coefficient","category":"section"},{"location":"getting-started/#Quick-Example:-Numerical-Differentiation","page":"Getting Started","title":"Quick Example: Numerical Differentiation","text":"The most powerful application of multicomplex numbers is computing derivatives with machine precision:\n\n# Compute the derivative of f(x) = sin(x) at x = π/4\nf(x) = sin(x)\n\n# Use an extremely small step size (impossible with finite differences!)\nh = 1e-100\nx = π/4 + h*im1\n\n# Evaluate the function\nresult = f(x)\n\n# Extract the derivative from the imaginary part\nderivative = imag(result) / h\n\n# Compare to exact value: cos(π/4) = √2/2 ≈ 0.7071...\ncos(π/4)\n\nThe result matches the exact derivative to machine precision!","category":"section"},{"location":"getting-started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Background: Learn the mathematics behind multicomplex numbers\nUser Guide: Detailed exploration of all features\nTutorials: Practical applications including numerical differentiation and NMR spectroscopy\nAPI Reference: Complete function documentation","category":"section"},{"location":"tutorials/#tutorials","page":"Tutorials","title":"Tutorials","text":"This section provides practical tutorials for common use cases of multicomplex numbers.","category":"section"},{"location":"tutorials/#Tutorial-1:-Numerical-Differentiation","page":"Tutorials","title":"Tutorial 1: Numerical Differentiation","text":"The multicomplex step method is the primary application of multicomplex numbers. It extends the complex step derivative to compute higher-order derivatives with machine precision, avoiding the subtractive cancellation errors that plague finite difference methods.","category":"section"},{"location":"tutorials/#The-Problem-with-Finite-Differences","page":"Tutorials","title":"The Problem with Finite Differences","text":"Traditional numerical differentiation uses finite differences:\n\nf(x) approx fracf(x+h) - f(x)h\n\nThis suffers from a fundamental trade-off:\n\nLarge h: Truncation error dominates (formula is only approximate)\nSmall h: Roundoff error dominates (subtractive cancellation in f(x+h) - f(x))\n\nThe optimal h is typically around √ε ≈ 10⁻⁸ for Float64, limiting accuracy to about 8 digits.","category":"section"},{"location":"tutorials/#The-Complex-Step-Method","page":"Tutorials","title":"The Complex Step Method","text":"For an analytic function f, we have the Taylor expansion:\n\nf(x + ih) = f(x) + ih cdot f(x) - frach^22f(x) - fracih^36f(x) + \n\nTaking the imaginary part:\n\ntextImf(x + ih) = h cdot f(x) + O(h^3)\n\nThus:\n\nf(x) approx fractextImf(x + ih)h\n\nSince we're not computing a difference, there's no subtractive cancellation! We can use arbitrarily small h, giving nearly machine-precision derivatives.","category":"section"},{"location":"tutorials/#First-Derivatives-with-im1","page":"Tutorials","title":"First Derivatives with im1","text":"using MulticomplexNumbers\n\n# Define a test function\nf(x) = sin(x) * exp(-x^2)\n\n# Compute derivative at x = 0.5\nx = 0.5\nh = 1e-100  # Extremely small step - impossible with finite differences!\n\n# Evaluate f at x + h*im1\nresult = f(x + h*im1)\n\n# Extract derivative from imaginary part\nf_prime = imag(result) / h\n\n# Compute exact derivative for comparison: f'(x) = cos(x)*exp(-x²) - 2x*sin(x)*exp(-x²)\nexact = cos(x)*exp(-x^2) - 2x*sin(x)*exp(-x^2)\n\n# Error\nabs(f_prime - exact)\n\nThe error is at the level of machine epsilon!","category":"section"},{"location":"tutorials/#Second-Derivatives-with-im1-and-im2","page":"Tutorials","title":"Second Derivatives with im1 and im2","text":"For second derivatives, we use bicomplex numbers (im1 and im2):\n\nf(x) approx fractextcomponent_i_1 i_2f(x + h cdot i_1 + h cdot i_2)h^2\n\nusing MulticomplexNumbers\n\n# Compute second derivative of f(x) = x^4 at x = 2\n# Exact answer: f''(x) = 12x² = 48\n\nx = 2.0\nh = 1e-50\n\n# Evaluate at x + h*im1 + h*im2\nresult = (x + h*im1 + h*im2)^4\n\n# The i₁i₂ component is at index 4: [1, i₁, i₂, i₁i₂]\nsecond_derivative = component(result, 4) / h^2\n\n# Exact value\nexact = 12 * x^2\n\nabs(second_derivative - exact)","category":"section"},{"location":"tutorials/#Third-Derivatives-with-im1,-im2,-and-im3","page":"Tutorials","title":"Third Derivatives with im1, im2, and im3","text":"using MulticomplexNumbers\n\n# Compute third derivative of f(x) = x^5 at x = 1\n# Exact answer: f'''(x) = 60x² = 60\n\nx = 1.0\nh = 1e-30\n\n# Evaluate at x + h*im1 + h*im2 + h*im3\nresult = (x + h*im1 + h*im2 + h*im3)^5\n\n# The i₁i₂i₃ component is at index 8\nthird_derivative = component(result, 8) / h^3\n\nexact = 60.0\nabs(third_derivative - exact)","category":"section"},{"location":"tutorials/#Practical-Tips-for-Numerical-Differentiation","page":"Tutorials","title":"Practical Tips for Numerical Differentiation","text":"Step size: Use h ≈ 10⁻¹⁰⁰/n for the n-th derivative. Smaller is generally better.\nComponent indices: For an n-th derivative, extract component 2^n from an order-n multicomplex number.\nComputational cost: Storage and computation scale as 2^n for the n-th derivative. For orders above ~10, this becomes expensive.\nFunction requirements: Your function must accept multicomplex arguments and use operations that work on them (+, -, *, /, ^, exp, log, sqrt, etc.).","category":"section"},{"location":"tutorials/#Derivative-Helper-Function","page":"Tutorials","title":"Derivative Helper Function","text":"Here's a convenient wrapper function:\n\nusing MulticomplexNumbers\n\n\"\"\"\n    derivative(f, x, n=1; h=1e-50)\n\nCompute the n-th derivative of f at x using multicomplex step method.\n\"\"\"\nfunction derivative(f, x::Real, n::Int=1; h::Real=1e-50)\n    if n < 1\n        return f(x)\n    elseif n == 1\n        result = f(x + h*im1)\n        return imag(result) / h\n    elseif n == 2\n        result = f(x + h*im1 + h*im2)\n        return component(result, 4) / h^2\n    elseif n == 3\n        result = f(x + h*im1 + h*im2 + h*im3)\n        return component(result, 8) / h^3\n    elseif n == 4\n        result = f(x + h*im1 + h*im2 + h*im3 + h*im4)\n        return component(result, 16) / h^4\n    else\n        error(\"Derivatives of order > 4 not implemented in this example\")\n    end\nend\n\n# Test it\nf(x) = sin(x)\nx = 1.0\n\nderivative(f, x, 1)  # f'(1) = cos(1) ≈ 0.5403\nderivative(f, x, 2)  # f''(1) = -sin(1) ≈ -0.8415\nderivative(f, x, 3)  # f'''(1) = -cos(1) ≈ -0.5403\nderivative(f, x, 4)  # f''''(1) = sin(1) ≈ 0.8415\n\n","category":"section"},{"location":"tutorials/#Tutorial-2:-Multi-dimensional-NMR-Signal-Processing","page":"Tutorials","title":"Tutorial 2: Multi-dimensional NMR Signal Processing","text":"Multicomplex numbers provide a natural representation for multi-dimensional NMR data, where each indirect dimension has its own imaginary component. This tutorial shows how to use multicomplex FFT for processing NMR-like signals.","category":"section"},{"location":"tutorials/#Background:-NMR-and-Quadrature-Detection","page":"Tutorials","title":"Background: NMR and Quadrature Detection","text":"In NMR spectroscopy:\n\nEach time-domain dimension uses quadrature detection, recording both real and imaginary components\nA 2D NMR experiment produces data that is complex in both dimensions\nThis is naturally represented as bicomplex numbers: z = a + b*i₁ + c*i₂ + d*i₁i₂\n\nWhere:\n\ni₁ represents the imaginary component of the direct (acquisition) dimension\ni₂ represents the imaginary component of the indirect dimension","category":"section"},{"location":"tutorials/#Setting-Up-FFT-Support","page":"Tutorials","title":"Setting Up FFT Support","text":"using MulticomplexNumbers\nusing FFTW  # This loads the FFT extension","category":"section"},{"location":"tutorials/#Creating-Test-Signals","page":"Tutorials","title":"Creating Test Signals","text":"using MulticomplexNumbers\nusing FFTW\n\n# Create a 2D time-domain signal (bicomplex)\n# This simulates a signal with frequencies in both dimensions\n\nfunction create_2d_signal(n1, n2, freq1, freq2, decay1, decay2)\n    t1 = range(0, 1, length=n1)  # Direct dimension time\n    t2 = range(0, 1, length=n2)  # Indirect dimension time\n\n    signal = Array{Multicomplex{Float64, 2, 4}}(undef, n1, n2)\n\n    for (j, τ2) in enumerate(t2), (i, τ1) in enumerate(t1)\n        # Signal in direct dimension: exp(i*ω₁*t₁) * exp(-t₁/T₂)\n        # Signal in indirect dimension: exp(i*ω₂*t₂) * exp(-t₂/T₂)\n\n        # Real/imaginary in dim 1 (im1)\n        s1_r = cos(2π * freq1 * τ1) * exp(-τ1 * decay1)\n        s1_i = sin(2π * freq1 * τ1) * exp(-τ1 * decay1)\n\n        # Real/imaginary in dim 2 (im2)\n        s2_r = cos(2π * freq2 * τ2) * exp(-τ2 * decay2)\n        s2_i = sin(2π * freq2 * τ2) * exp(-τ2 * decay2)\n\n        # Combine as bicomplex: (s1_r + s1_i*im1) * (s2_r + s2_i*im2)\n        # = s1_r*s2_r + s1_i*s2_r*im1 + s1_r*s2_i*im2 + s1_i*s2_i*im1*im2\n        signal[i, j] = Multicomplex(\n            s1_r * s2_r,     # real part\n            s1_i * s2_r,     # im1 coefficient\n            s1_r * s2_i,     # im2 coefficient\n            s1_i * s2_i      # im1*im2 coefficient\n        )\n    end\n\n    return signal\nend\n\n# Create a test signal\nn = 64\nsignal = create_2d_signal(n, n, 5.0, 10.0, 2.0, 3.0)\n# size(signal) => (64, 64)\n# eltype(signal) => Multicomplex{Float64, 2, 4}","category":"section"},{"location":"tutorials/#FFT-Along-Specific-Dimensions","page":"Tutorials","title":"FFT Along Specific Dimensions","text":"The fft! function performs in-place FFT along a specific imaginary unit:\n\nusing MulticomplexNumbers\nusing FFTW\n\n# Create a simple bicomplex array for demonstration\ndata = [Multicomplex(1.0, 0.0, 0.0, 0.0) for i in 1:8]\n\n# FFT along im1 (direct dimension)\nfft!(data, 1)\n# After FFT along im1: [8.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\n# Note: The original data is modified in-place","category":"section"},{"location":"tutorials/#Complete-2D-Transform-Example","page":"Tutorials","title":"Complete 2D Transform Example","text":"For a 2D NMR spectrum, you typically:\n\nFFT along the direct dimension (im1)\nFFT along the indirect dimension (im2)\n\nusing MulticomplexNumbers\nusing FFTW\n\n# Create a 2D bicomplex signal\nfunction make_test_fid()\n    n = 32\n    data = Array{Multicomplex{Float64, 2, 4}}(undef, n, n)\n\n    for j in 1:n, i in 1:n\n        # Simple oscillating signal\n        t1, t2 = (i-1)/n, (j-1)/n\n        ω1, ω2 = 3.0, 7.0  # Frequencies\n\n        r1, i1 = cos(2π*ω1*t1), sin(2π*ω1*t1)\n        r2, i2 = cos(2π*ω2*t2), sin(2π*ω2*t2)\n\n        data[i,j] = Multicomplex(r1*r2, i1*r2, r1*i2, i1*i2)\n    end\n    return data\nend\n\nfid = make_test_fid()\n\n# Transform both dimensions\nfid_copy = copy(fid)\nfft!(fid_copy, 1)  # Direct dimension\nfft!(fid_copy, 2)  # Indirect dimension\n\n# Peak at position (4, 8) contains the signal\nabs(realest(fid_copy[4, 8]))  # Should be large","category":"section"},{"location":"tutorials/#Working-with-Higher-Dimensions","page":"Tutorials","title":"Working with Higher Dimensions","text":"For 3D NMR data, use tricomplex numbers with im1, im2, im3:\n\nusing MulticomplexNumbers\nusing FFTW\n\n# Create 3D data with tricomplex numbers\ndata_3d = Array{Multicomplex{Float64, 3, 8}}(undef, 16, 16, 16)\n\n# Fill with test signal...\n# (Each element has 8 components: 1, im1, im2, im1*im2, im3, im1*im3, im2*im3, im1*im2*im3)\n\n# FFT each dimension\nfft!(data_3d, 1)  # Direct dimension (im1)\nfft!(data_3d, 2)  # First indirect (im2)\nfft!(data_3d, 3)  # Second indirect (im3)","category":"section"},{"location":"tutorials/#Viewing-Multicomplex-Data-as-Complex","page":"Tutorials","title":"Viewing Multicomplex Data as Complex","text":"The ascomplex function provides views of multicomplex arrays as complex arrays:\n\nusing MulticomplexNumbers\n\n# Create bicomplex data\ndata = [Multicomplex(1.0, 2.0, 3.0, 4.0) for _ in 1:4]\n\n# View as complex along im1\nview_im1 = ascomplex(data, 1)\nsize(view_im1)\n\n# View as complex along im2\nview_im2 = ascomplex(data, 2)\nsize(view_im2)","category":"section"},{"location":"tutorials/#Tips-for-NMR-Applications","page":"Tutorials","title":"Tips for NMR Applications","text":"Choose the right order: Use bicomplex (N=2) for 2D, tricomplex (N=3) for 3D, etc.\nComponent ordering: Components follow a binary pattern:\nOrder 2: [1, i₁, i₂, i₁i₂] (indices 1-4)\nOrder 3: [1, i₁, i₂, i₁i₂, i₃, i₁i₃, i₂i₃, i₁i₂i₃] (indices 1-8)\nIntegration with NMRTools.jl: See NMRTools.jl for comprehensive NMR data handling that builds on this package.\nMemory efficiency: Multicomplex arrays store components contiguously, making them cache-friendly for numerical operations.\n\n","category":"section"},{"location":"tutorials/#Tutorial-3:-Matrix-Representations","page":"Tutorials","title":"Tutorial 3: Matrix Representations","text":"Every multicomplex number has an equivalent matrix representation that preserves algebraic operations. This is useful for understanding the structure and for implementing functions like exp, log, and sqrt.","category":"section"},{"location":"tutorials/#The-Matrix-Representation","page":"Tutorials","title":"The Matrix Representation","text":"For complex numbers, the 2×2 matrix representation is:\n\na + bi mapsto beginpmatrix a  -b  b  a endpmatrix\n\nFor bicomplex numbers, this extends to 4×4 matrices, and so on.\n\nusing MulticomplexNumbers\n\n# Complex number matrix representation\nz = 3.0 + 4.0*im1\nM_z = matrep(z)\n\n# Verify: multiplication via matrices\nw = 1.0 + 2.0*im1\nM_w = matrep(w)\n\n# Matrix product corresponds to multicomplex product\nz * w\nMulticomplex{1}(M_z * M_w * [1, 0])  # First column of product","category":"section"},{"location":"tutorials/#Using-Matrix-Representations","page":"Tutorials","title":"Using Matrix Representations","text":"using MulticomplexNumbers\n\n# Bicomplex number\nz = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\nM = matrep(z)\n\n# The matrix is 4×4 for bicomplex\nsize(M)\n\n# First column contains the components\nM[:, 1]\nflat(z)\n\n# Matrix functions give multicomplex functions\nusing LinearAlgebra\nexp_M = exp(M)\nexp_z = exp(z)\n\n# Compare first columns\nexp_M[:, 1]\nflat(exp_z)\n\nThis matrix approach is how exp, log, sqrt, and ^ are implemented internally.\n\n","category":"section"},{"location":"tutorials/#Summary","page":"Tutorials","title":"Summary","text":"Application Order Units Used Key Functions\n1st derivative 1 im1 imag(f(x + h*im1)) / h\n2nd derivative 2 im1, im2 component(result, 4) / h²\n3rd derivative 3 im1, im2, im3 component(result, 8) / h³\n2D NMR 2 im1, im2 fft!(data, 1), fft!(data, 2)\n3D NMR 3 im1, im2, im3 fft!(data, 1), fft!(data, 2), fft!(data, 3)","category":"section"},{"location":"tutorials/#References","page":"Tutorials","title":"References","text":"Complex Step Approximation (Nick Higham)\nLantoine, G., Russell, R. P., Dargent, T. \"Using Multicomplex Variables for Automatic Computation of High-order Derivatives.\" ACM TOMS, 2012.\nNIST Multicomplex Report","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"This page provides quick examples demonstrating key features of MulticomplexNumbers.jl.\n\n","category":"section"},{"location":"examples/#Basic-Multicomplex-Algebra","page":"Examples","title":"Basic Multicomplex Algebra","text":"","category":"section"},{"location":"examples/#Imaginary-Units","page":"Examples","title":"Imaginary Units","text":"Multicomplex units im1 through im6 are defined. Each squares to -1:\n\njulia> using MulticomplexNumbers\n\njulia> im1\n0 + 1*im1\n\njulia> im1 * im1\n-1 + 0*im1\n\njulia> im2\n(0 + 0*im1) + (1 + 0*im1)*im2\n\njulia> im2 * im2\n(-1 + 0*im1) + (0 + 0*im1)*im2\n\nProducts of different units commute and create new basis elements:\n\njulia> im1 * im2\n(0 + 0*im1) + (0 + 1*im1)*im2\n\njulia> im1 * im2 == im2 * im1\ntrue\n\nInterestingly, products of distinct units square to +1 (hyperbolic units):\n\njulia> (im1 * im2)^2\n(1 + 0*im1) + (0 + 0*im1)*im2","category":"section"},{"location":"examples/#Creating-Numbers","page":"Examples","title":"Creating Numbers","text":"julia> z = 1.0 + 2.0*im1  # Complex (order 1)\n1.0 + 2.0*im1\n\njulia> w = 3.0 + 4.0*im1 + 5.0*im2 + 6.0*im1*im2  # Bicomplex (order 2)\n(3.0 + 4.0*im1) + (5.0 + 6.0*im1)*im2\n\njulia> Multicomplex(1.0, 2.0)  # From components\n1.0 + 2.0*im1\n\njulia> Multicomplex(1+2im)  # From Complex\n1 + 2*im1\n\n","category":"section"},{"location":"examples/#Arithmetic","page":"Examples","title":"Arithmetic","text":"","category":"section"},{"location":"examples/#Basic-Operations","page":"Examples","title":"Basic Operations","text":"julia> a = 1.0 + 2.0*im1;\n\njulia> b = 3.0 + 4.0*im1;\n\njulia> a + b\n4.0 + 6.0*im1\n\njulia> a * b\n-5.0 + 10.0*im1\n\njulia> a / b\n0.44 + 0.08*im1","category":"section"},{"location":"examples/#Powers-and-Transcendentals","page":"Examples","title":"Powers and Transcendentals","text":"julia> z = 1.0 + 1.0*im1;\n\njulia> z^2\n0.0 + 2.0*im1\n\njulia> exp(z)\n1.4686939399158851 + 2.2873552871788423*im1\n\njulia> log(z)\n0.34657359027997264 + 0.7853981633974483*im1\n\njulia> sqrt(z)\n1.0986841134678098 + 0.45508986056222733*im1\n\n","category":"section"},{"location":"examples/#Component-Access","page":"Examples","title":"Component Access","text":"","category":"section"},{"location":"examples/#Extracting-Parts","page":"Examples","title":"Extracting Parts","text":"julia> z = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2;\n\njulia> real(z)  # Order N-1 real part\n1.0 + 2.0*im1\n\njulia> imag(z)  # Order N-1 imaginary part\n3.0 + 4.0*im1\n\njulia> flat(z)  # All components\n4-element StaticArraysCore.SVector{4, Float64} with indices SOneTo(4):\n 1.0\n 2.0\n 3.0\n 4.0\n\njulia> realest(z)  # First component\n1.0\n\njulia> component(z, 4)  # Specific component (im1*im2 coefficient)\n4.0","category":"section"},{"location":"examples/#Order-and-Properties","page":"Examples","title":"Order and Properties","text":"julia> order(1.0 + im1)\n1\n\njulia> order(1.0 + im1 + im2)\n2\n\njulia> isreal(5.0 + 0.0*im1)\ntrue\n\njulia> isreal(1.0 + 2.0*im1)\nfalse\n\n","category":"section"},{"location":"examples/#Matrix-Representation","page":"Examples","title":"Matrix Representation","text":"Every multicomplex number has an equivalent matrix:\n\njulia> z = 1.0 + 2.0*im1;\n\njulia> M = matrep(z)\n2×2 StaticArraysCore.SMatrix{2, 2, Float64, 4} with indices SOneTo(2)×SOneTo(2):\n 1.0  -2.0\n 2.0   1.0\n\nThe matrix representation preserves algebra:\n\njulia> w = 3.0 + 4.0*im1;\n\njulia> flat(z * w)\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n -5.0\n 10.0\n\njulia> (matrep(z) * matrep(w))[:, 1]\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n -5.0\n 10.0\n\n","category":"section"},{"location":"examples/#Numerical-Differentiation","page":"Examples","title":"Numerical Differentiation","text":"","category":"section"},{"location":"examples/#First-Derivative","page":"Examples","title":"First Derivative","text":"julia> f(x) = x^3;\n\njulia> x = 2.0;\n\njulia> h = 1e-100;\n\njulia> derivative = imag(f(x + h*im1)) / h\n12.0\n\njulia> # Exact: f'(x) = 3x² = 12","category":"section"},{"location":"examples/#Second-Derivative","page":"Examples","title":"Second Derivative","text":"julia> f(x) = x^4;\n\njulia> x = 2.0;\n\njulia> h = 1e-50;\n\njulia> result = f(x + h*im1 + h*im2);\n\njulia> second_derivative = component(result, 4) / h^2\n48.0\n\njulia> # Exact: f''(x) = 12x² = 48\n\n","category":"section"},{"location":"examples/#Complex-Views","page":"Examples","title":"Complex Views","text":"Convert multicomplex arrays to complex arrays:\n\njulia> data = [Multicomplex(1.0, 2.0, 3.0, 4.0)];\n\njulia> c = ascomplex(data, 1);\n\njulia> size(c)\n(2, 1)\n\njulia> c[1]\n1.0 + 2.0im\n\njulia> c[2]\n3.0 + 4.0im\n\n","category":"section"},{"location":"examples/#Type-Promotions","page":"Examples","title":"Type Promotions","text":"Different orders automatically promote:\n\njulia> a = 1.0 + im1;  # Order 1\n\njulia> b = 2.0 + im2;  # Order 2\n\njulia> c = a + b;  # Promoted to order 2\n\njulia> order(c)\n2\n\nScalars and Complex promote to multicomplex:\n\njulia> z = 1.0 + im1;\n\njulia> z + 5.0\n6.0 + 1.0*im1\n\njulia> z + (2.0 + 3.0im)\n3.0 + 4.0*im1\n\n","category":"section"},{"location":"examples/#FFT-(requires-FFTW)","page":"Examples","title":"FFT (requires FFTW)","text":"using MulticomplexNumbers\nusing FFTW\n\n# Create bicomplex signal\nsignal = [Multicomplex(cos(2π*k/64), sin(2π*k/64), 0.0, 0.0) for k in 0:63]\n\n# FFT along im1\nfft!(signal, 1)\n\n# Peak at frequency 1\nabs(realest(signal[2]))  # Should be large\n\n","category":"section"},{"location":"examples/#High-Precision","page":"Examples","title":"High Precision","text":"julia> z = big\"1.0\" + big\"2.0\" * im1;\n\njulia> typeof(z)\nMulticomplex{BigFloat, 1, 2}\n\njulia> exp(z)\n-1.131204383756813... + 2.471726672004818...*im1\n\n","category":"section"},{"location":"examples/#Quick-Reference","page":"Examples","title":"Quick Reference","text":"Task Code\nCreate order 1 1.0 + 2.0*im1\nCreate order 2 1.0 + 2.0*im1 + 3.0*im2\nGet components flat(z)\nGet order order(z)\n1st derivative imag(f(x + h*im1)) / h\n2nd derivative component(f(x + h*im1 + h*im2), 4) / h²\nMatrix form matrep(z)\nAs complex ascomplex(data, unit)","category":"section"},{"location":"userguide/#userguide","page":"User Guide","title":"User Guide","text":"This guide provides a complete tour of MulticomplexNumbers.jl functionality.\n\n","category":"section"},{"location":"userguide/#The-Multicomplex-Type","page":"User Guide","title":"The Multicomplex Type","text":"The core type is Multicomplex{T,N,C} where:\n\nT: The base scalar type (must be <:Real, e.g., Float64, BigFloat)\nN: The order (number of imaginary units)\nC: The number of components (always C = 2^N)\n\nusing MulticomplexNumbers\n\n# Examine types\nz = 1.0 + 2.0*im1\ntypeof(z)\n\nw = 1.0 + 2.0*im1 + 3.0*im2\ntypeof(w)","category":"section"},{"location":"userguide/#Type-Hierarchy","page":"User Guide","title":"Type Hierarchy","text":"Number\n└── Multicomplex{T,N,C}\n    ├── Multicomplex{Float64,0,1}  # Just a real number\n    ├── Multicomplex{Float64,1,2}  # Complex-like\n    ├── Multicomplex{Float64,2,4}  # Bicomplex\n    ├── Multicomplex{Float64,3,8}  # Tricomplex\n    └── ...\n\n","category":"section"},{"location":"userguide/#Creating-Multicomplex-Numbers","page":"User Guide","title":"Creating Multicomplex Numbers","text":"","category":"section"},{"location":"userguide/#Using-Imaginary-Units","page":"User Guide","title":"Using Imaginary Units","text":"The package exports im1 through im6:\n\nusing MulticomplexNumbers\n\nim1  # First imaginary unit\nim2  # Second imaginary unit\nim3  # Third imaginary unit\n\n# Build multicomplex numbers by combination\nz = 3.0 + 4.0*im1                           # Order 1\nw = 1.0 + 2.0*im1 + 3.0*im2                 # Order 2 (auto-promoted)\nv = 1.0 + im1 + im2 + im3 + im1*im2*im3    # Order 3","category":"section"},{"location":"userguide/#Direct-Constructors","page":"User Guide","title":"Direct Constructors","text":"using MulticomplexNumbers\n\n# Order 0 (scalar)\nMulticomplex(5.0)\n\n# Order 1 (from two reals)\nMulticomplex(1.0, 2.0)  # = 1 + 2*im1\n\n# Order 1 (from Complex)\nMulticomplex(3.0 + 4.0im)  # = 3 + 4*im1\n\n# Order 2 (from four reals): 1 + 2*im1 + 3*im2 + 4*im1*im2\nMulticomplex(1.0, 2.0, 3.0, 4.0)\n\n# Order 2 (from two Complex numbers)\nMulticomplex(1.0 + 2.0im, 3.0 + 4.0im)  # = (1+2*im1) + (3+4*im1)*im2","category":"section"},{"location":"userguide/#Type-Specific-Constructors","page":"User Guide","title":"Type-Specific Constructors","text":"using MulticomplexNumbers\nusing StaticArrays\n\n# Construct with explicit type parameters\nz = Multicomplex{Float64,2,4}(1.0)  # Bicomplex 1.0\n\n# From StaticArrays SVector\nv = SVector(1.0, 2.0, 3.0, 4.0)\nMulticomplex{2}(v)\n\n","category":"section"},{"location":"userguide/#Accessing-Components","page":"User Guide","title":"Accessing Components","text":"","category":"section"},{"location":"userguide/#Real-and-Imaginary-Parts","page":"User Guide","title":"Real and Imaginary Parts","text":"The real() and imag() functions return multicomplex numbers of order N-1:\n\nusing MulticomplexNumbers\n\nz = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\n\n# For order 2: real/imag return order 1\nreal(z)  # The \"real\" part with respect to im2\nimag(z)  # The \"imaginary\" part with respect to im2\n\n# Apply recursively\nreal(real(z))  # Gets the truly real component","category":"section"},{"location":"userguide/#Direct-Component-Access","page":"User Guide","title":"Direct Component Access","text":"using MulticomplexNumbers\n\nz = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\n\n# Get all components as a vector\nflat(z)\n\n# Get a specific component (1-indexed)\ncomponent(z, 1)  # Coefficient of 1\ncomponent(z, 2)  # Coefficient of im1\ncomponent(z, 3)  # Coefficient of im2\ncomponent(z, 4)  # Coefficient of im1*im2\n\n# Get the first (most real) component\nrealest(z)","category":"section"},{"location":"userguide/#Component-Ordering","page":"User Guide","title":"Component Ordering","text":"Components follow a binary pattern based on which imaginary units are present:\n\nOrder Index Basis Element\n1 1 1\n1 2 i₁\n2 1 1\n2 2 i₁\n2 3 i₂\n2 4 i₁i₂\n3 1 1\n3 2 i₁\n3 3 i₂\n3 4 i₁i₂\n3 5 i₃\n3 6 i₁i₃\n3 7 i₂i₃\n3 8 i₁i₂i₃\n\nThe pattern: index k has the units corresponding to bits set in k-1 (0-indexed).\n\n","category":"section"},{"location":"userguide/#Arithmetic-Operations","page":"User Guide","title":"Arithmetic Operations","text":"","category":"section"},{"location":"userguide/#Basic-Arithmetic","page":"User Guide","title":"Basic Arithmetic","text":"using MulticomplexNumbers\n\na = 1.0 + 2.0*im1 + 3.0*im2\nb = 2.0 - 1.0*im1 + 0.5*im2\n\n# Addition and subtraction\na + b\na - b\n-a\n\n# Scalar operations\n3.0 * a\na / 2.0\na + 5.0","category":"section"},{"location":"userguide/#Multiplication","page":"User Guide","title":"Multiplication","text":"Multicomplex multiplication uses the matrix representation internally:\n\nusing MulticomplexNumbers\n\na = 1.0 + 2.0*im1\nb = 3.0 + 4.0*im1\n\na * b  # = (1*3 - 2*4) + (1*4 + 2*3)*im1 = -5 + 10*im1\n\n# Verify the algebra\nim1 * im1  # = -1\nim1 * im2  # = im1*im2 (distinct product)\nim2 * im1  # Commutative!","category":"section"},{"location":"userguide/#Division","page":"User Guide","title":"Division","text":"Division works except when dividing by zero divisors:\n\nusing MulticomplexNumbers\n\na = 1.0 + 2.0*im1\nb = 3.0 + 4.0*im1\n\na / b\ninv(b)  # = 1/b\n\nwarning: Zero Divisors\nFor N ≥ 2, some non-zero multicomplex numbers cannot be inverted:z = 1.0 + 1.0*im1*im2  # This has a zero divisor issue\n# (1 + im1*im2)(1 - im1*im2) = 1 - (im1*im2)² = 1 - 1 = 0","category":"section"},{"location":"userguide/#Powers","page":"User Guide","title":"Powers","text":"using MulticomplexNumbers\n\nz = 1.0 + 0.5*im1\n\nz^2\nz^3\nz^0.5  # Non-integer powers work too\nz^(-1)  # Same as inv(z)","category":"section"},{"location":"userguide/#Transcendental-Functions","page":"User Guide","title":"Transcendental Functions","text":"using MulticomplexNumbers\n\nz = 0.5 + 0.25*im1\n\nexp(z)\nlog(z)\nsqrt(z)\n\n# Verify: exp(log(z)) ≈ z\nexp(log(z))\n\n","category":"section"},{"location":"userguide/#Conjugation-and-Norms","page":"User Guide","title":"Conjugation and Norms","text":"","category":"section"},{"location":"userguide/#Multicomplex-Conjugation","page":"User Guide","title":"Multicomplex Conjugation","text":"Conjugation inverts the sign of the highest-order imaginary component:\n\nusing MulticomplexNumbers\n\nz = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\n\nconj(z)  # Inverts im2 component sign\n\n# For order 1, this matches complex conjugation\nw = 1.0 + 2.0*im1\nconj(w)","category":"section"},{"location":"userguide/#Absolute-Values-and-Norms","page":"User Guide","title":"Absolute Values and Norms","text":"using MulticomplexNumbers\nusing LinearAlgebra\n\nz = 3.0 + 4.0*im1\n\nabs2(z)  # Sum of squares of components\nabs(z)   # sqrt(abs2(z))\nnorm(z)  # Euclidean norm (same as abs for order 1)\n\n","category":"section"},{"location":"userguide/#Type-Conversions-and-Promotion","page":"User Guide","title":"Type Conversions and Promotion","text":"","category":"section"},{"location":"userguide/#Converting-to-Multicomplex","page":"User Guide","title":"Converting to Multicomplex","text":"using MulticomplexNumbers\n\n# Reals promote to multicomplex\nz = 1.0 + 2.0*im1\nz + 3.0  # 3.0 is promoted to Multicomplex\n\n# Complex promotes too\nz + (3.0 + 4.0im)\n\n# Different orders promote to the higher order\na = 1.0 + im1        # Order 1\nb = 2.0 + im2        # Order 2\na + b                 # Result is order 2","category":"section"},{"location":"userguide/#Converting-from-Multicomplex","page":"User Guide","title":"Converting from Multicomplex","text":"using MulticomplexNumbers\n\nz = Multicomplex(5.0)  # Order 0\n\n# Convert to real if purely real\nFloat64(z)\n\n# This would error for non-real multicomplex:\n# Float64(1.0 + 2.0*im1)  # InexactError\n\n","category":"section"},{"location":"userguide/#Testing-Properties","page":"User Guide","title":"Testing Properties","text":"using MulticomplexNumbers\n\nz = 1.0 + 2.0*im1\nw = 5.0 + 0.0*im1\n\nisreal(z)   # false\nisreal(w)   # true (imaginary part is zero)\n\nisinteger(w)  # true\nisinteger(z)  # false\n\niszero(z)     # false\niszero(0.0 + 0.0*im1)  # true\n\nisone(1.0 + 0.0*im1)   # true\n\nisfinite(z)  # true\nisnan(z)     # false\nisinf(z)     # false\n\n","category":"section"},{"location":"userguide/#Matrix-Representations","page":"User Guide","title":"Matrix Representations","text":"Every multicomplex number can be represented as a real matrix:\n\nusing MulticomplexNumbers\n\nz = 1.0 + 2.0*im1\nM = matrep(z)\n\n# Matrix properties\nsize(M)\n\n# The first column contains the components\nM[:, 1]\nflat(z)\n\n# Bicomplex gives 4×4\nw = 1.0 + 2.0*im1 + 3.0*im2 + 4.0*im1*im2\nsize(matrep(w))\n\n","category":"section"},{"location":"userguide/#Complex-Array-Views","page":"User Guide","title":"Complex Array Views","text":"The ascomplex function views multicomplex arrays as complex arrays:\n\nusing MulticomplexNumbers\n\n# Create a bicomplex array\ndata = [Multicomplex(1.0, 2.0, 3.0, 4.0) for i in 1:3]\n\n# View as complex along im1\nc1 = ascomplex(data, 1)\nsize(c1)  # (2, 3) - the 2 is from 2^(N-1)\n\n# View as complex along im2\nc2 = ascomplex(data, 2)\nsize(c2)\n\n# Default is highest order\nc_default = ascomplex(data)  # Same as ascomplex(data, 2)\n\n","category":"section"},{"location":"userguide/#FFT-Support","page":"User Guide","title":"FFT Support","text":"When FFTW is loaded, in-place FFT is available:\n\nusing MulticomplexNumbers\nusing FFTW\n\n# Create bicomplex data\ndata = [Multicomplex(rand(4)...) for _ in 1:64]\n\n# FFT along im1 (treating im1 as the complex unit)\nfft!(data, 1)\n\n# FFT along im2\nfft!(data, 2)\n\nSee the Tutorials for complete NMR examples.\n\n","category":"section"},{"location":"userguide/#Working-with-Higher-Precision","page":"User Guide","title":"Working with Higher Precision","text":"MulticomplexNumbers supports any Real scalar type:\n\nusing MulticomplexNumbers\n\n# BigFloat for high precision\nz = big\"1.0\" + big\"2.0\"*im1\ntypeof(z)\n\n# Compute with high precision\nexp(z)\n\n","category":"section"},{"location":"userguide/#Performance-Tips","page":"User Guide","title":"Performance Tips","text":"Use Float64: It's the fastest for most applications\nAvoid order changes: Mixing orders triggers promotion, which allocates\nPre-allocate arrays: For FFT operations, reuse arrays when possible\nConsider StaticArrays: The internal representation uses SVector, which is stack-allocated\nProfile high orders: Order N uses 2^N components. Order 6 has 64 components per number!\n\n","category":"section"},{"location":"userguide/#Common-Patterns","page":"User Guide","title":"Common Patterns","text":"","category":"section"},{"location":"userguide/#Pattern-1:-Numerical-Differentiation","page":"User Guide","title":"Pattern 1: Numerical Differentiation","text":"using MulticomplexNumbers\n\nf(x) = sin(x) * cos(x)\nx = 1.0\nh = 1e-100\n\n# First derivative\nf_prime = imag(f(x + h*im1)) / h\n\n# Exact: f'(x) = cos(2x)\ncos(2x)","category":"section"},{"location":"userguide/#Pattern-2:-Processing-2D-Data","page":"User Guide","title":"Pattern 2: Processing 2D Data","text":"using MulticomplexNumbers\nusing FFTW\n\n# Create 2D bicomplex data\ndata = [Multicomplex(rand(4)...) for i in 1:64, j in 1:64]\n\n# FFT both dimensions\nfft!(data, 1)  # Direct\nfft!(data, 2)  # Indirect","category":"section"},{"location":"userguide/#Pattern-3:-Working-with-Components","page":"User Guide","title":"Pattern 3: Working with Components","text":"using MulticomplexNumbers\n\n# Extract the im1*im2 coefficient from a result\nz = (1.0 + im1 + im2)^2\ncomponent(z, 4)  # The im1*im2 term\n\n","category":"section"},{"location":"userguide/#See-Also","page":"User Guide","title":"See Also","text":"Background: Mathematical foundations\nTutorials: Practical applications\nAPI Reference: Complete function documentation","category":"section"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/#Introduction","page":"Background","title":"Introduction","text":"MulticomplexNumbers.jl provides a Julia implementation of multicomplex numbers. These numbers are a generalisation of complex numbers, recursively defined to contain multiple imaginary numbers, i_1, i_2 etc. Unlike Clifford algebras, these numbers commute, i.e. i_1i_2=i_2i_1.","category":"section"},{"location":"background/#Algebra-of-the-multicomplex-numbers","page":"Background","title":"Algebra of the multicomplex numbers","text":"","category":"section"},{"location":"background/#Recursive-Definition","page":"Background","title":"Recursive Definition","text":"Multicomplex numbers are built recursively from real numbers:\n\nmathbbC_0 = mathbbR\n\nmathbbC_n = mathbbC_n-1 + i_n mathbbC_n-1\n\nThis means:\n\nmathbbC_0: Real numbers (1 component)\nmathbbC_1 = mathbbR + i_1mathbbR: Complex numbers (2 components)\nmathbbC_2 = mathbbC_1 + i_2mathbbC_1: Bicomplex numbers (4 components)\nmathbbC_3 = mathbbC_2 + i_3mathbbC_2: Tricomplex numbers (8 components)\nmathbbC_n: Has 2^n real components","category":"section"},{"location":"background/#Fundamental-Properties","page":"Background","title":"Fundamental Properties","text":"Each imaginary unit squares to negative one:\n\ni_k^2 = -1 quad textfor all  k geq 1\n\nCrucially, imaginary units commute with each other:\n\ni_j i_k = i_k i_j quad textfor all  j k\n\nThis commutativity distinguishes multicomplex numbers from quaternions and other hypercomplex systems where imaginary units anticommute.\n\nInterestingly, products of distinct imaginary units square to positive one:\n\n(i_j i_k)^2 = i_j i_k i_j i_k = i_j^2 i_k^2 = (-1)(-1) = +1 quad text(when  j neq k text)\n\nThis reveals an important property: products like i_1 i_2 are hyperbolic units (they square to +1), not elliptic units (which square to -1). This is why mathbbC_n for n geq 2 contains zero divisors.","category":"section"},{"location":"background/#Component-Representation","page":"Background","title":"Component Representation","text":"A general multicomplex number m in mathbbC_n can be written as:\n\nFor n = 1 (complex):\n\nm = a + b cdot i_1\n\nFor n = 2 (bicomplex):\n\nm = a + b cdot i_1 + c cdot i_2 + d cdot i_1 i_2\n\nFor n = 3 (tricomplex):\n\nm = a + b cdot i_1 + c cdot i_2 + d cdot i_1 i_2 + e cdot i_3 + f cdot i_1 i_3 + g cdot i_2 i_3 + h cdot i_1 i_2 i_3\n\nIn general, mathbbC_n has 2^n basis elements formed by all possible products of the imaginary units 1 i_1 i_2 ldots i_n and their combinations.","category":"section"},{"location":"background/#Recursive-Structure","page":"Background","title":"Recursive Structure","text":"Any multicomplex number m in mathbbC_n can be uniquely written as:\n\nm = a + i_n cdot b\n\nwhere a b in mathbbC_n-1 are called the \"real\" and \"imaginary\" parts (with respect to i_n).\n\nThis recursive structure is central to the implementation: the real() and imag() functions return multicomplex numbers of order n-1.","category":"section"},{"location":"background/#Matrix-Representations","page":"Background","title":"Matrix Representations","text":"","category":"section"},{"location":"background/#The-Matrix-Homomorphism","page":"Background","title":"The Matrix Homomorphism","text":"Every multicomplex number can be faithfully represented as a real matrix. This representation is a ring homomorphism that preserves addition and multiplication.\n\nFor mathbbC_1 (complex numbers), the familiar 2×2 representation:\n\na + b cdot i_1 mapsto beginpmatrix a  -b  b  a endpmatrix\n\nFor mathbbC_2 (bicomplex numbers), a 4×4 matrix where the structure is built recursively:\n\n(a + b cdot i_1) + (c + d cdot i_1) cdot i_2 mapsto beginpmatrix M(a + b cdot i_1)  -M(c + d cdot i_1)  M(c + d cdot i_1)  M(a + b cdot i_1) endpmatrix\n\nwhere M(cdot) denotes the matrix representation.","category":"section"},{"location":"background/#Recursive-Construction","page":"Background","title":"Recursive Construction","text":"For m = a + i_n cdot b in mathbbC_n with a b in mathbbC_n-1:\n\nM(m) = beginpmatrix M(a)  -M(b)  M(b)  M(a) endpmatrix\n\nThis 2^n times 2^n matrix has the property that the first column contains all 2^n components of the multicomplex number.","category":"section"},{"location":"background/#Why-Matrix-Representation?","page":"Background","title":"Why Matrix Representation?","text":"The matrix representation enables:\n\nMultiplication: m_1 times m_2 computed via M(m_1) times M(m_2)\nDivision: m_1  m_2 computed via M(m_1) times M(m_2)^-1\nPowers: m^p computed via matrix power\nTranscendental functions: exp(m), log(m), sqrtm via matrix functions\n\nThe result is extracted from the first column of the resulting matrix.","category":"section"},{"location":"background/#Zero-Divisors","page":"Background","title":"Zero Divisors","text":"Unlike complex numbers, bicomplex and higher multicomplex numbers have zero divisors: non-zero elements whose product is zero.\n\nFor example, in mathbbC_2:\n\n(1 + i_1 i_2)(1 - i_1 i_2) = 1 - (i_1 i_2)^2 = 1 - 1 = 0\n\nThis means:\n\nDivision by some non-zero elements is undefined (singular matrix)\nmathbbC_n for n geq 2 is not a division algebra","category":"section"},{"location":"background/#Arithmetic","page":"Background","title":"Arithmetic","text":"","category":"section"},{"location":"background/#Addition-and-Subtraction","page":"Background","title":"Addition and Subtraction","text":"Component-wise operations:\n\n(a + b cdot i_1) + (c + d cdot i_1) = (a + c) + (b + d) cdot i_1\n\nThis extends naturally to all orders.","category":"section"},{"location":"background/#Multiplication","page":"Background","title":"Multiplication","text":"Multiplication follows from the algebraic rules. For complex numbers:\n\n(a + b cdot i_1)(c + d cdot i_1) = (ac - bd) + (ad + bc) cdot i_1\n\nFor bicomplex and higher orders, multiplication is most efficiently computed via the matrix representation.","category":"section"},{"location":"background/#Conjugation","page":"Background","title":"Conjugation","text":"Multicomplex conjugation inverts the sign of the highest imaginary component:\n\noverlinem = overlinea + i_n cdot b = a - i_n cdot b\n\nwhere a b in mathbbC_n-1.\n\nNote: This is different from complex conjugation applied to all imaginary units.","category":"section"},{"location":"background/#Norm","page":"Background","title":"Norm","text":"The Euclidean norm is defined as:\n\nm = sqrtsum_k=1^2^n c_k^2\n\nwhere c_k are the real components of the multicomplex number.","category":"section"},{"location":"background/#Applications","page":"Background","title":"Applications","text":"","category":"section"},{"location":"background/#Numerical-Differentiation","page":"Background","title":"Numerical Differentiation","text":"The primary application of multicomplex numbers is high-order numerical differentiation. The multicomplex step method extends the complex step derivative to compute higher-order derivatives with machine precision accuracy.\n\nFor a function f extended to multicomplex arguments:\n\nf(x + h cdot i_1) = f(x) + h cdot f(x) cdot i_1 + O(h^2)\n\nThe first derivative is extracted from the i_1 component:\n\nf(x) approx fractextIm_1f(x + h cdot i_1)h\n\nThis avoids subtractive cancellation errors that plague finite difference methods.\n\nFor second derivatives using bicomplex numbers:\n\nf(x) approx fractextcomponent_i_1 i_2f(x + h cdot i_1 + h cdot i_2)h^2","category":"section"},{"location":"background/#Signal-Processing","page":"Background","title":"Signal Processing","text":"Multicomplex Fourier transforms enable processing of signals with multiple independent phase components, useful in certain NMR spectroscopy applications.","category":"section"},{"location":"background/#References","page":"Background","title":"References","text":"NIST report on multicomplex algebra: https://nvlpubs.nist.gov/nistpubs/jres/126/jres.126.033.pdf\nCasado & Hewson (2020): Algorithm 1008: Multicomplex Number Class for Matlab. ACM Trans Math Softw. http://dx.doi.org/10.1145/3378542\nNIST C++ implementation: https://github.com/usnistgov/multicomplex","category":"section"},{"location":"#MulticomplexNumbers.jl","page":"Home","title":"MulticomplexNumbers.jl","text":"A Julia package for representing multicomplex numbers and performing multicomplex algebra.","category":"section"},{"location":"#What-are-Multicomplex-Numbers?","page":"Home","title":"What are Multicomplex Numbers?","text":"Multicomplex numbers are a generalization of complex numbers, recursively defined to contain multiple imaginary units (i_1, i_2, i_3, ...). Unlike quaternions and Clifford algebras, these imaginary units commute: i_1 i_2 = i_2 i_1.\n\nmathbbC_0 = mathbbR quad mathbbC_n = mathbbC_n-1 + i_n mathbbC_n-1\n\nOrder Name Components Example\n0 Real 1 5.0\n1 Complex 2 1 + 2i₁\n2 Bicomplex 4 1 + 2i₁ + 3i₂ + 4i₁i₂\n3 Tricomplex 8 1 + 2i₁ + 3i₂ + 4i₃ + ...","category":"section"},{"location":"#Key-Applications","page":"Home","title":"Key Applications","text":"","category":"section"},{"location":"#High-Precision-Numerical-Differentiation","page":"Home","title":"High-Precision Numerical Differentiation","text":"The multicomplex step method computes derivatives with machine precision, avoiding the subtractive cancellation errors that limit finite difference methods:\n\nusing MulticomplexNumbers\n\n# First derivative with machine precision\nf(x) = sin(x) * exp(-x^2)\nh = 1e-100  # Impossibly small for finite differences!\nx = 0.5 + h*im1\nderivative = imag(f(x)) / h  # Exact to ~15 digits","category":"section"},{"location":"#Multi-dimensional-NMR-Spectroscopy","page":"Home","title":"Multi-dimensional NMR Spectroscopy","text":"Bicomplex and higher-order multicomplex numbers naturally represent multi-dimensional NMR data where each indirect dimension has its own imaginary component:\n\nusing MulticomplexNumbers\nusing FFTW\n\n# 2D NMR: bicomplex numbers (im1 = direct, im2 = indirect)\nfid = [Multicomplex(data...) for data in time_domain]\nfft!(fid, 1)  # Transform direct dimension\nfft!(fid, 2)  # Transform indirect dimension","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using Pkg\nPkg.add(\"MulticomplexNumbers\")\n\nusing MulticomplexNumbers\n\n# Create multicomplex numbers\nz = 1.0 + 2.0*im1                    # Complex (order 1)\nw = 1.0 + 2.0*im1 + 3.0*im2          # Bicomplex (order 2)\n\n# Arithmetic\nz * w\nexp(w)\nsqrt(w)\n\n# Numerical differentiation\nh = 1e-100\nx = 2.0 + h*im1\nf_prime = imag(x^3) / h  # = 12.0 (exact!)","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Full arithmetic: +, -, *, /, ^, exp, log, sqrt\nImaginary units: im1 through im6 for orders 1-6\nType-stable: Uses StaticArrays for stack-allocated, cache-friendly storage\nFFT support: In-place multicomplex FFT via FFTW extension\nHigh precision: Works with BigFloat and other Real types\nJulia integration: Proper Number subtype with promotion rules","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Pages = [\n    \"getting-started.md\",\n    \"background.md\",\n    \"userguide.md\",\n    \"tutorials.md\",\n    \"examples.md\",\n    \"api.md\"\n]\nDepth = 1\n\n","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"MulticomplexNumbers.jl is a registered package:\n\nusing Pkg\nPkg.add(\"MulticomplexNumbers\")\n\nFor FFT support:\n\nPkg.add(\"FFTW\")\n\n","category":"section"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"NMRTools.jl: A library for handling NMR data in Julia (uses this package)\nDualNumbers.jl: Dual numbers for first-order automatic differentiation\nForwardDiff.jl: Forward mode automatic differentiation\nHyperDualNumbers.jl: Hyper-dual numbers for second derivatives\nCliffordAlgebras.jl: Clifford and geometric algebras\n\n","category":"section"},{"location":"#References","page":"Home","title":"References","text":"NIST Report: Bell, I. H., Deiters, U. K. (2021). \"Precise Numerical Differentiation of Thermodynamic Functions with Multicomplex Variables.\" NIST J. Res. 126:033\nACM Algorithm: Casado, J. M. V., Hewson, R. (2020). \"Algorithm 1008: Multicomplex Number Class for Matlab.\" ACM Trans. Math. Softw. 46:1-26. doi:10.1145/3378542\nNIST Implementation: github.com/usnistgov/multicomplex - C++ multicomplex library\nOriginal Method: Lantoine, G., Russell, R. P., Dargent, T. (2012). \"Using Multicomplex Variables for Automatic Computation of High-order Derivatives.\" ACM Trans. Math. Softw. 38(3):16. doi:10.1145/2168773.2168774\n\n","category":"section"},{"location":"#Authors","page":"Home","title":"Authors","text":"Chris Waudby, UCL School of Pharmacy, London (UK)","category":"section"},{"location":"#Citing","page":"Home","title":"Citing","text":"If you find this package useful, please cite:\n\nWaudby, C. A. (2022). MulticomplexNumbers.jl. github.com/waudbygroup/MulticomplexNumbers.jl","category":"section"},{"location":"#License","page":"Home","title":"License","text":"MulticomplexNumbers.jl is licensed under the MIT license; see LICENSE for the full license text.","category":"section"}]
}
